import { B as Block } from './Button-bd009e9a.js';
import { u as uploadToHuggingFace, c as copy } from './utils-013c0d40.js';
import { d as dequal } from './index-21d69e4c.js';
import { S as ShareButton } from './ShareButton-5feea5fe.js';
import { S as Static } from './Index-7fdff9d2.js';
import { r as resolve_wasm_src } from './file-url-6213a515.js';
import { I as Image } from './Image-e7664ad6.js';
import { V as Video } from './Video-0f7b23bd.js';
import './Index.svelte_svelte_type_style_lang-a6238841.js';
import { M as MarkdownCode } from './Example.svelte_svelte_type_style_lang-8b4acbf0.js';
import './index-10ead756.js';
import { C as Check } from './Check-f7edb5d9.js';
import { C as Copy } from './Copy-a69620a8.js';
import { B as BlockLabel } from './BlockLabel-5d99d786.js';
import './IconButton-9a708715.js';
import './prism-python-2c627c47.js';
import './svelte/svelte.js';

/* home/runner/work/gradio/gradio/js/icons/src/Chat.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$8,
	append: append$5,
	attr: attr$7,
	detach: detach$8,
	init: init$8,
	insert: insert$8,
	noop: noop$5,
	safe_not_equal: safe_not_equal$8,
	svg_element: svg_element$2
} = window.__gradio__svelte__internal;
function create_fragment$8(ctx) {
	let svg;
	let path0;
	let path1;

	return {
		c() {
			svg = svg_element$2("svg");
			path0 = svg_element$2("path");
			path1 = svg_element$2("path");
			attr$7(path0, "fill", "currentColor");
			attr$7(path0, "d", "M17.74 30L16 29l4-7h6a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h9v2H6a4 4 0 0 1-4-4V8a4 4 0 0 1 4-4h20a4 4 0 0 1 4 4v12a4 4 0 0 1-4 4h-4.84Z");
			attr$7(path1, "fill", "currentColor");
			attr$7(path1, "d", "M8 10h16v2H8zm0 6h10v2H8z");
			attr$7(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$7(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
			attr$7(svg, "aria-hidden", "true");
			attr$7(svg, "role", "img");
			attr$7(svg, "class", "iconify iconify--carbon");
			attr$7(svg, "width", "100%");
			attr$7(svg, "height", "100%");
			attr$7(svg, "preserveAspectRatio", "xMidYMid meet");
			attr$7(svg, "viewBox", "0 0 32 32");
		},
		m(target, anchor) {
			insert$8(target, svg, anchor);
			append$5(svg, path0);
			append$5(svg, path1);
		},
		p: noop$5,
		i: noop$5,
		o: noop$5,
		d(detaching) {
			if (detaching) {
				detach$8(svg);
			}
		}
	};
}

class Chat extends SvelteComponent$8 {
	constructor(options) {
		super();
		init$8(this, options, null, create_fragment$8, safe_not_equal$8, {});
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/Dislike.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$7,
	append: append$4,
	attr: attr$6,
	detach: detach$7,
	init: init$7,
	insert: insert$7,
	noop: noop$4,
	safe_not_equal: safe_not_equal$7,
	svg_element: svg_element$1
} = window.__gradio__svelte__internal;
function create_fragment$7(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_fill_value;

	return {
		c() {
			svg = svg_element$1("svg");
			path0 = svg_element$1("path");
			path1 = svg_element$1("path");
			attr$6(path0, "stroke", "currentColor");
			attr$6(path0, "stroke-width", "1.5");
			attr$6(path0, "stroke-linecap", "round");
			attr$6(path0, "d", "M16.472 3.5H4.1a.6.6 0 0 0-.6.6v9.8a.6.6 0 0 0 .6.6h2.768a2 2 0 0 1 1.715.971l2.71 4.517a1.631 1.631 0 0 0 2.961-1.308l-1.022-3.408a.6.6 0 0 1 .574-.772h4.575a2 2 0 0 0 1.93-2.526l-1.91-7A2 2 0 0 0 16.473 3.5Z");
			attr$6(path1, "stroke", "currentColor");
			attr$6(path1, "stroke-width", "1.5");
			attr$6(path1, "stroke-linecap", "round");
			attr$6(path1, "stroke-linejoin", "round");
			attr$6(path1, "d", "M7 14.5v-11");
			attr$6(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$6(svg, "viewBox", "0 0 24 24");
			attr$6(svg, "fill", svg_fill_value = /*selected*/ ctx[0] ? "currentColor" : "none");
			attr$6(svg, "stroke-width", "1.5");
			attr$6(svg, "color", "currentColor");
		},
		m(target, anchor) {
			insert$7(target, svg, anchor);
			append$4(svg, path0);
			append$4(svg, path1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*selected*/ 1 && svg_fill_value !== (svg_fill_value = /*selected*/ ctx[0] ? "currentColor" : "none")) {
				attr$6(svg, "fill", svg_fill_value);
			}
		},
		i: noop$4,
		o: noop$4,
		d(detaching) {
			if (detaching) {
				detach$7(svg);
			}
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { selected } = $$props;

	$$self.$$set = $$props => {
		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
	};

	return [selected];
}

class Dislike extends SvelteComponent$7 {
	constructor(options) {
		super();
		init$7(this, options, instance$7, create_fragment$7, safe_not_equal$7, { selected: 0 });
	}
}

/* home/runner/work/gradio/gradio/js/icons/src/Like.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$6,
	append: append$3,
	attr: attr$5,
	detach: detach$6,
	init: init$6,
	insert: insert$6,
	noop: noop$3,
	safe_not_equal: safe_not_equal$6,
	svg_element
} = window.__gradio__svelte__internal;
function create_fragment$6(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_fill_value;

	return {
		c() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr$5(path0, "stroke", "currentColor");
			attr$5(path0, "stroke-width", "1.5");
			attr$5(path0, "stroke-linecap", "round");
			attr$5(path0, "d", "M16.472 20H4.1a.6.6 0 0 1-.6-.6V9.6a.6.6 0 0 1 .6-.6h2.768a2 2 0 0 0 1.715-.971l2.71-4.517a1.631 1.631 0 0 1 2.961 1.308l-1.022 3.408a.6.6 0 0 0 .574.772h4.575a2 2 0 0 1 1.93 2.526l-1.91 7A2 2 0 0 1 16.473 20Z");
			attr$5(path1, "stroke", "currentColor");
			attr$5(path1, "stroke-width", "1.5");
			attr$5(path1, "stroke-linecap", "round");
			attr$5(path1, "stroke-linejoin", "round");
			attr$5(path1, "d", "M7 20V9");
			attr$5(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr$5(svg, "viewBox", "0 0 24 24");
			attr$5(svg, "fill", svg_fill_value = /*selected*/ ctx[0] ? "currentColor" : "none");
			attr$5(svg, "stroke-width", "1.5");
			attr$5(svg, "color", "currentColor");
		},
		m(target, anchor) {
			insert$6(target, svg, anchor);
			append$3(svg, path0);
			append$3(svg, path1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*selected*/ 1 && svg_fill_value !== (svg_fill_value = /*selected*/ ctx[0] ? "currentColor" : "none")) {
				attr$5(svg, "fill", svg_fill_value);
			}
		},
		i: noop$3,
		o: noop$3,
		d(detaching) {
			if (detaching) {
				detach$6(svg);
			}
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { selected } = $$props;

	$$self.$$set = $$props => {
		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
	};

	return [selected];
}

class Like extends SvelteComponent$6 {
	constructor(options) {
		super();
		init$6(this, options, instance$6, create_fragment$6, safe_not_equal$6, { selected: 0 });
	}
}

const format_chat_for_sharing = async (chat) => {
  let messages = await Promise.all(
    chat.map(async (message_pair) => {
      return await Promise.all(
        message_pair.map(async (message, i) => {
          if (message === null)
            return "";
          let speaker_emoji = i === 0 ? "ðŸ˜ƒ" : "ðŸ¤–";
          let html_content = "";
          if (typeof message === "string") {
            const regexPatterns = {
              audio: /<audio.*?src="(\/file=.*?)"/g,
              video: /<video.*?src="(\/file=.*?)"/g,
              image: /<img.*?src="(\/file=.*?)".*?\/>|!\[.*?\]\((\/file=.*?)\)/g
            };
            html_content = message;
            for (let [_, regex] of Object.entries(regexPatterns)) {
              let match;
              while ((match = regex.exec(message)) !== null) {
                const fileUrl = match[1] || match[2];
                const newUrl = await uploadToHuggingFace(fileUrl, "url");
                html_content = html_content.replace(fileUrl, newUrl);
              }
            }
          } else {
            if (!message?.url)
              return "";
            const file_url = await uploadToHuggingFace(message.url, "url");
            if (message.mime_type?.includes("audio")) {
              html_content = `<audio controls src="${file_url}"></audio>`;
            } else if (message.mime_type?.includes("video")) {
              html_content = file_url;
            } else if (message.mime_type?.includes("image")) {
              html_content = `<img src="${file_url}" />`;
            }
          }
          return `${speaker_emoji}: ${html_content}`;
        })
      );
    })
  );
  return messages.map(
    (message_pair) => message_pair.join(
      message_pair[0] !== "" && message_pair[1] !== "" ? "\n" : ""
    )
  ).join("\n");
};

/* home/runner/work/gradio/gradio/js/audio/shared/Audio.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$5,
	assign: assign$1,
	compute_rest_props,
	detach: detach$5,
	element: element$5,
	exclude_internal_props,
	get_spread_update: get_spread_update$1,
	init: init$5,
	insert: insert$5,
	listen: listen$3,
	noop: noop$2,
	run_all: run_all$2,
	safe_not_equal: safe_not_equal$5,
	set_attributes,
	src_url_equal
} = window.__gradio__svelte__internal;
const { createEventDispatcher: createEventDispatcher$1 } = window.__gradio__svelte__internal;
function create_fragment$5(ctx) {
	let audio;
	let audio_src_value;
	let mounted;
	let dispose;

	let audio_levels = [
		{
			src: audio_src_value = /*resolved_src*/ ctx[0]
		},
		/*$$restProps*/ ctx[2]
	];

	let audio_data = {};

	for (let i = 0; i < audio_levels.length; i += 1) {
		audio_data = assign$1(audio_data, audio_levels[i]);
	}

	return {
		c() {
			audio = element$5("audio");
			set_attributes(audio, audio_data);
		},
		m(target, anchor) {
			insert$5(target, audio, anchor);

			if (!mounted) {
				dispose = [
					listen$3(audio, "play", /*dispatch*/ ctx[1].bind(null, "play")),
					listen$3(audio, "pause", /*dispatch*/ ctx[1].bind(null, "pause")),
					listen$3(audio, "ended", /*dispatch*/ ctx[1].bind(null, "ended"))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			set_attributes(audio, audio_data = get_spread_update$1(audio_levels, [
				dirty & /*resolved_src*/ 1 && !src_url_equal(audio.src, audio_src_value = /*resolved_src*/ ctx[0]) && { src: audio_src_value },
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
			]));
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) {
				detach$5(audio);
			}

			mounted = false;
			run_all$2(dispose);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	const omit_props_names = ["src"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { src = undefined } = $$props;
	let resolved_src;

	// The `src` prop can be updated before the Promise from `resolve_wasm_src` is resolved.
	// In such a case, the resolved value for the old `src` has to be discarded,
	// This variable `latest_src` is used to pick up only the value resolved for the latest `src` prop.
	let latest_src;

	const dispatch = createEventDispatcher$1();

	$$self.$$set = $$new_props => {
		$$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('src' in $$new_props) $$invalidate(3, src = $$new_props.src);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*src, latest_src*/ 24) {
			{
				// In normal (non-Wasm) Gradio, the `<audio>` element should be rendered with the passed `src` props immediately
				// without waiting for `resolve_wasm_src()` to resolve.
				// If it waits, a black image is displayed until the async task finishes
				// and it leads to undesirable flickering.
				// So set `src` to `resolved_src` here.
				$$invalidate(0, resolved_src = src);

				$$invalidate(4, latest_src = src);
				const resolving_src = src;

				resolve_wasm_src(resolving_src).then(s => {
					if (latest_src === resolving_src) {
						$$invalidate(0, resolved_src = s);
					}
				});
			}
		}
	};

	return [resolved_src, dispatch, $$restProps, src, latest_src];
}

class Audio extends SvelteComponent$5 {
	constructor(options) {
		super();
		init$5(this, options, instance$5, create_fragment$5, safe_not_equal$5, { src: 3 });
	}
}

const Copy_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/chatbot/shared/Copy.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$4,
	append: append$2,
	attr: attr$4,
	check_outros: check_outros$2,
	create_component: create_component$3,
	destroy_component: destroy_component$3,
	detach: detach$4,
	element: element$4,
	group_outros: group_outros$2,
	init: init$4,
	insert: insert$4,
	listen: listen$2,
	mount_component: mount_component$3,
	safe_not_equal: safe_not_equal$4,
	space: space$3,
	transition_in: transition_in$3,
	transition_out: transition_out$3
} = window.__gradio__svelte__internal;
const { onDestroy } = window.__gradio__svelte__internal;
function create_if_block_1$2(ctx) {
	let copy;
	let current;
	copy = new Copy({});

	return {
		c() {
			create_component$3(copy.$$.fragment);
		},
		m(target, anchor) {
			mount_component$3(copy, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$3(copy.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$3(copy.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$3(copy, detaching);
		}
	};
}

// (53:1) {#if copied}
function create_if_block$2(ctx) {
	let check;
	let current;
	check = new Check({});

	return {
		c() {
			create_component$3(check.$$.fragment);
		},
		m(target, anchor) {
			mount_component$3(check, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$3(check.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$3(check.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$3(check, detaching);
		}
	};
}

function create_fragment$4(ctx) {
	let button;
	let t;
	let button_aria_label_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = !/*copied*/ ctx[0] && create_if_block_1$2();
	let if_block1 = /*copied*/ ctx[0] && create_if_block$2();

	return {
		c() {
			button = element$4("button");
			if (if_block0) if_block0.c();
			t = space$3();
			if (if_block1) if_block1.c();
			attr$4(button, "class", "action svelte-rvlubk");
			attr$4(button, "title", "copy");
			attr$4(button, "aria-label", button_aria_label_value = /*copied*/ ctx[0] ? "Copied message" : "Copy message");
		},
		m(target, anchor) {
			insert$4(target, button, anchor);
			if (if_block0) if_block0.m(button, null);
			append$2(button, t);
			if (if_block1) if_block1.m(button, null);
			current = true;

			if (!mounted) {
				dispose = listen$2(button, "click", /*handle_copy*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!/*copied*/ ctx[0]) {
				if (if_block0) {
					if (dirty & /*copied*/ 1) {
						transition_in$3(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$2();
					if_block0.c();
					transition_in$3(if_block0, 1);
					if_block0.m(button, t);
				}
			} else if (if_block0) {
				group_outros$2();

				transition_out$3(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$2();
			}

			if (/*copied*/ ctx[0]) {
				if (if_block1) {
					if (dirty & /*copied*/ 1) {
						transition_in$3(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$2();
					if_block1.c();
					transition_in$3(if_block1, 1);
					if_block1.m(button, null);
				}
			} else if (if_block1) {
				group_outros$2();

				transition_out$3(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros$2();
			}

			if (!current || dirty & /*copied*/ 1 && button_aria_label_value !== (button_aria_label_value = /*copied*/ ctx[0] ? "Copied message" : "Copy message")) {
				attr$4(button, "aria-label", button_aria_label_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in$3(if_block0);
			transition_in$3(if_block1);
			current = true;
		},
		o(local) {
			transition_out$3(if_block0);
			transition_out$3(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$4(button);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let copied = false;
	let { value } = $$props;
	let timer;

	function copy_feedback() {
		$$invalidate(0, copied = true);
		if (timer) clearTimeout(timer);

		timer = setTimeout(
			() => {
				$$invalidate(0, copied = false);
			},
			2000
		);
	}

	async function handle_copy() {
		if ("clipboard" in navigator) {
			await navigator.clipboard.writeText(value);
			copy_feedback();
		} else {
			const textArea = document.createElement("textarea");
			textArea.value = value;
			textArea.style.position = "absolute";
			textArea.style.left = "-999999px";
			document.body.prepend(textArea);
			textArea.select();

			try {
				document.execCommand("copy");
				copy_feedback();
			} catch(error) {
				console.error(error);
			} finally {
				textArea.remove();
			}
		}
	}

	onDestroy(() => {
		if (timer) clearTimeout(timer);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(2, value = $$props.value);
	};

	return [copied, handle_copy, value];
}

class Copy_1 extends SvelteComponent$4 {
	constructor(options) {
		super();
		init$4(this, options, instance$4, create_fragment$4, safe_not_equal$4, { value: 2 });
	}
}

const LikeDislike_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/chatbot/shared/LikeDislike.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$3,
	attr: attr$3,
	create_component: create_component$2,
	destroy_component: destroy_component$2,
	detach: detach$3,
	element: element$3,
	init: init$3,
	insert: insert$3,
	listen: listen$1,
	mount_component: mount_component$2,
	run_all: run_all$1,
	safe_not_equal: safe_not_equal$3,
	space: space$2,
	transition_in: transition_in$2,
	transition_out: transition_out$2
} = window.__gradio__svelte__internal;
function create_fragment$3(ctx) {
	let button0;
	let like;
	let button0_aria_label_value;
	let t;
	let button1;
	let dislike;
	let button1_aria_label_value;
	let current;
	let mounted;
	let dispose;

	like = new Like({
			props: { selected: /*selected*/ ctx[1] === "like" }
		});

	dislike = new Dislike({
			props: {
				selected: /*selected*/ ctx[1] === "dislike"
			}
		});

	return {
		c() {
			button0 = element$3("button");
			create_component$2(like.$$.fragment);
			t = space$2();
			button1 = element$3("button");
			create_component$2(dislike.$$.fragment);
			attr$3(button0, "aria-label", button0_aria_label_value = /*selected*/ ctx[1] === "like" ? "clicked like" : "like");
			attr$3(button0, "class", "svelte-3snf3m");

			attr$3(button1, "aria-label", button1_aria_label_value = /*selected*/ ctx[1] === "dislike"
			? "clicked dislike"
			: "dislike");

			attr$3(button1, "class", "svelte-3snf3m");
		},
		m(target, anchor) {
			insert$3(target, button0, anchor);
			mount_component$2(like, button0, null);
			insert$3(target, t, anchor);
			insert$3(target, button1, anchor);
			mount_component$2(dislike, button1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen$1(button0, "click", /*click_handler*/ ctx[2]),
					listen$1(button1, "click", /*click_handler_1*/ ctx[3])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const like_changes = {};
			if (dirty & /*selected*/ 2) like_changes.selected = /*selected*/ ctx[1] === "like";
			like.$set(like_changes);

			if (!current || dirty & /*selected*/ 2 && button0_aria_label_value !== (button0_aria_label_value = /*selected*/ ctx[1] === "like" ? "clicked like" : "like")) {
				attr$3(button0, "aria-label", button0_aria_label_value);
			}

			const dislike_changes = {};
			if (dirty & /*selected*/ 2) dislike_changes.selected = /*selected*/ ctx[1] === "dislike";
			dislike.$set(dislike_changes);

			if (!current || dirty & /*selected*/ 2 && button1_aria_label_value !== (button1_aria_label_value = /*selected*/ ctx[1] === "dislike"
			? "clicked dislike"
			: "dislike")) {
				attr$3(button1, "aria-label", button1_aria_label_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in$2(like.$$.fragment, local);
			transition_in$2(dislike.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$2(like.$$.fragment, local);
			transition_out$2(dislike.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$3(button0);
				detach$3(t);
				detach$3(button1);
			}

			destroy_component$2(like);
			destroy_component$2(dislike);
			mounted = false;
			run_all$1(dispose);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { handle_action } = $$props;
	let selected = null;

	const click_handler = () => {
		$$invalidate(1, selected = "like");
		handle_action(selected);
	};

	const click_handler_1 = () => {
		$$invalidate(1, selected = "dislike");
		handle_action(selected);
	};

	$$self.$$set = $$props => {
		if ('handle_action' in $$props) $$invalidate(0, handle_action = $$props.handle_action);
	};

	return [handle_action, selected, click_handler, click_handler_1];
}

class LikeDislike extends SvelteComponent$3 {
	constructor(options) {
		super();
		init$3(this, options, instance$3, create_fragment$3, safe_not_equal$3, { handle_action: 0 });
	}
}

const Pending_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/chatbot/shared/Pending.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$2,
	attr: attr$2,
	detach: detach$2,
	element: element$2,
	init: init$2,
	insert: insert$2,
	noop: noop$1,
	safe_not_equal: safe_not_equal$2,
	set_style: set_style$1
} = window.__gradio__svelte__internal;
function create_fragment$2(ctx) {
	let div3;

	return {
		c() {
			div3 = element$2("div");

			div3.innerHTML = `<span class="sr-only">Loading content</span> <div class="dot-flashing svelte-1gpwetz"></div>
	Â 
	<div class="dot-flashing svelte-1gpwetz"></div>
	Â 
	<div class="dot-flashing svelte-1gpwetz"></div>`;

			attr$2(div3, "class", "message pending svelte-1gpwetz");
			attr$2(div3, "role", "status");
			attr$2(div3, "aria-label", "Loading response");
			attr$2(div3, "aria-live", "polite");

			set_style$1(div3, "border-radius", /*layout*/ ctx[0] === "bubble"
			? "var(--radius-xxl)"
			: "none");
		},
		m(target, anchor) {
			insert$2(target, div3, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*layout*/ 1) {
				set_style$1(div3, "border-radius", /*layout*/ ctx[0] === "bubble"
				? "var(--radius-xxl)"
				: "none");
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach$2(div3);
			}
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { layout = "bubble" } = $$props;

	$$self.$$set = $$props => {
		if ('layout' in $$props) $$invalidate(0, layout = $$props.layout);
	};

	return [layout];
}

class Pending extends SvelteComponent$2 {
	constructor(options) {
		super();
		init$2(this, options, instance$2, create_fragment$2, safe_not_equal$2, { layout: 0 });
	}
}

const ChatBot_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/chatbot/shared/ChatBot.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$1,
	action_destroyer,
	append: append$1,
	attr: attr$1,
	binding_callbacks,
	bubble,
	check_outros: check_outros$1,
	create_component: create_component$1,
	destroy_component: destroy_component$1,
	destroy_each,
	detach: detach$1,
	element: element$1,
	empty,
	ensure_array_like,
	group_outros: group_outros$1,
	init: init$1,
	insert: insert$1,
	listen,
	mount_component: mount_component$1,
	noop,
	null_to_empty,
	run_all,
	safe_not_equal: safe_not_equal$1,
	set_data,
	set_style,
	space: space$1,
	text,
	toggle_class,
	transition_in: transition_in$1,
	transition_out: transition_out$1
} = window.__gradio__svelte__internal;const { beforeUpdate, afterUpdate, createEventDispatcher } = window.__gradio__svelte__internal;
function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[35] = list[i];
	child_ctx[37] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[38] = list[i];
	child_ctx[40] = i;
	return child_ctx;
}

// (94:0) {#if show_share_button && value !== null && value.length > 0}
function create_if_block_12(ctx) {
	let div_1;
	let sharebutton;
	let current;

	sharebutton = new ShareButton({
			props: {
				i18n: /*i18n*/ ctx[13],
				formatter: format_chat_for_sharing,
				value: /*value*/ ctx[0]
			}
		});

	sharebutton.$on("error", /*error_handler*/ ctx[21]);
	sharebutton.$on("share", /*share_handler*/ ctx[22]);

	return {
		c() {
			div_1 = element$1("div");
			create_component$1(sharebutton.$$.fragment);
			attr$1(div_1, "class", "share-button svelte-1lcyrx4");
		},
		m(target, anchor) {
			insert$1(target, div_1, anchor);
			mount_component$1(sharebutton, div_1, null);
			current = true;
		},
		p(ctx, dirty) {
			const sharebutton_changes = {};
			if (dirty[0] & /*i18n*/ 8192) sharebutton_changes.i18n = /*i18n*/ ctx[13];
			if (dirty[0] & /*value*/ 1) sharebutton_changes.value = /*value*/ ctx[0];
			sharebutton.$set(sharebutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(sharebutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(sharebutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div_1);
			}

			destroy_component$1(sharebutton);
		}
	};
}

// (114:2) {#if value !== null}
function create_if_block$1(ctx) {
	let t;
	let if_block_anchor;
	let current;
	let each_value = ensure_array_like(/*value*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out$1(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block = /*pending_message*/ ctx[2] && create_if_block_1$1(ctx);

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space$1();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert$1(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert$1(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value, layout, avatar_images, bubble_full_width, show_copy_button, handle_like, likeable, render_markdown, rtl, selectable, handle_select, latex_delimiters, sanitize_html, line_breaks, scroll*/ 483291) {
				each_value = ensure_array_like(/*value*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in$1(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in$1(each_blocks[i], 1);
						each_blocks[i].m(t.parentNode, t);
					}
				}

				group_outros$1();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros$1();
			}

			if (/*pending_message*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*pending_message*/ 4) {
						transition_in$1(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					transition_in$1(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros$1();

				transition_out$1(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros$1();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in$1(each_blocks[i]);
			}

			transition_in$1(if_block);
			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out$1(each_blocks[i]);
			}

			transition_out$1(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(t);
				detach$1(if_block_anchor);
			}

			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d(detaching);
		}
	};
}

// (117:5) {#if message !== null}
function create_if_block_2(ctx) {
	let div1;
	let t0;
	let div0;
	let button;
	let show_if;
	let show_if_1;
	let show_if_2;
	let current_block_type_index;
	let if_block1;
	let button_dir_value;
	let button_aria_label_value;
	let t1;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*avatar_images*/ ctx[8][/*j*/ ctx[40]] !== null && create_if_block_11(ctx);

	const if_block_creators = [
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_if_block_9,
		create_if_block_10
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty[0] & /*value*/ 1) show_if = null;
		if (dirty[0] & /*value*/ 1) show_if_1 = null;
		if (dirty[0] & /*value*/ 1) show_if_2 = null;
		if (typeof /*message*/ ctx[38] === "string") return 0;
		if (show_if == null) show_if = !!(/*message*/ ctx[38] !== null && /*message*/ ctx[38].file?.mime_type?.includes("audio"));
		if (show_if) return 1;
		if (show_if_1 == null) show_if_1 = !!(/*message*/ ctx[38] !== null && /*message*/ ctx[38].file?.mime_type?.includes("video"));
		if (show_if_1) return 2;
		if (show_if_2 == null) show_if_2 = !!(/*message*/ ctx[38] !== null && /*message*/ ctx[38].file?.mime_type?.includes("image"));
		if (show_if_2) return 3;
		if (/*message*/ ctx[38] !== null && /*message*/ ctx[38].file?.url !== null) return 4;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	function click_handler() {
		return /*click_handler*/ ctx[29](/*i*/ ctx[37], /*j*/ ctx[40], /*message*/ ctx[38]);
	}

	function keydown_handler(...args) {
		return /*keydown_handler*/ ctx[30](/*i*/ ctx[37], /*j*/ ctx[40], /*message*/ ctx[38], ...args);
	}

	let if_block2 = (/*likeable*/ ctx[4] && /*j*/ ctx[40] !== 0 || /*show_copy_button*/ ctx[7] && /*message*/ ctx[38] && typeof /*message*/ ctx[38] === "string") && create_if_block_3(ctx);

	return {
		c() {
			div1 = element$1("div");
			if (if_block0) if_block0.c();
			t0 = space$1();
			div0 = element$1("div");
			button = element$1("button");
			if (if_block1) if_block1.c();
			t1 = space$1();
			if (if_block2) if_block2.c();
			attr$1(button, "data-testid", /*j*/ ctx[40] == 0 ? "user" : "bot");
			attr$1(button, "dir", button_dir_value = /*rtl*/ ctx[6] ? "rtl" : "ltr");

			attr$1(button, "aria-label", button_aria_label_value = (/*j*/ ctx[40] == 0 ? "user" : "bot") + "'s message: " + (typeof /*message*/ ctx[38] === "string"
			? /*message*/ ctx[38]
			: `a file of type ${/*message*/ ctx[38].file?.mime_type}, ${/*message*/ ctx[38].file?.alt_text ?? /*message*/ ctx[38].file?.orig_name ?? ""}`));

			attr$1(button, "class", "svelte-1lcyrx4");
			toggle_class(button, "latest", /*i*/ ctx[37] === /*value*/ ctx[0].length - 1);
			toggle_class(button, "message-markdown-disabled", !/*render_markdown*/ ctx[11]);
			toggle_class(button, "selectable", /*selectable*/ ctx[3]);
			set_style(button, "user-select", `text`);
			set_style(button, "text-align", /*rtl*/ ctx[6] ? "right" : "left");
			attr$1(div0, "class", "message " + (/*j*/ ctx[40] == 0 ? 'user' : 'bot') + " svelte-1lcyrx4");
			toggle_class(div0, "message-fit", /*layout*/ ctx[14] === "bubble" && !/*bubble_full_width*/ ctx[10]);
			toggle_class(div0, "panel-full-width", /*layout*/ ctx[14] === "panel");
			toggle_class(div0, "message-bubble-border", /*layout*/ ctx[14] === "bubble");
			toggle_class(div0, "message-markdown-disabled", !/*render_markdown*/ ctx[11]);
			set_style(div0, "text-align", /*rtl*/ ctx[6] && /*j*/ ctx[40] == 0 ? "left" : "right");
			attr$1(div1, "class", div1_class_value = "message-row " + /*layout*/ ctx[14] + " " + (/*j*/ ctx[40] == 0 ? 'user-row' : 'bot-row') + " svelte-1lcyrx4");
		},
		m(target, anchor) {
			insert$1(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append$1(div1, t0);
			append$1(div1, div0);
			append$1(div0, button);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(button, null);
			}

			append$1(div1, t1);
			if (if_block2) if_block2.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button, "click", click_handler),
					listen(button, "keydown", keydown_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*avatar_images*/ ctx[8][/*j*/ ctx[40]] !== null) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*avatar_images*/ 256) {
						transition_in$1(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_11(ctx);
					if_block0.c();
					transition_in$1(if_block0, 1);
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				group_outros$1();

				transition_out$1(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$1();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block1) {
					group_outros$1();

					transition_out$1(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros$1();
				}

				if (~current_block_type_index) {
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in$1(if_block1, 1);
					if_block1.m(button, null);
				} else {
					if_block1 = null;
				}
			}

			if (!current || dirty[0] & /*rtl*/ 64 && button_dir_value !== (button_dir_value = /*rtl*/ ctx[6] ? "rtl" : "ltr")) {
				attr$1(button, "dir", button_dir_value);
			}

			if (!current || dirty[0] & /*value*/ 1 && button_aria_label_value !== (button_aria_label_value = (/*j*/ ctx[40] == 0 ? "user" : "bot") + "'s message: " + (typeof /*message*/ ctx[38] === "string"
			? /*message*/ ctx[38]
			: `a file of type ${/*message*/ ctx[38].file?.mime_type}, ${/*message*/ ctx[38].file?.alt_text ?? /*message*/ ctx[38].file?.orig_name ?? ""}`))) {
				attr$1(button, "aria-label", button_aria_label_value);
			}

			if (!current || dirty[0] & /*value*/ 1) {
				toggle_class(button, "latest", /*i*/ ctx[37] === /*value*/ ctx[0].length - 1);
			}

			if (!current || dirty[0] & /*render_markdown*/ 2048) {
				toggle_class(button, "message-markdown-disabled", !/*render_markdown*/ ctx[11]);
			}

			if (!current || dirty[0] & /*selectable*/ 8) {
				toggle_class(button, "selectable", /*selectable*/ ctx[3]);
			}

			if (dirty[0] & /*rtl*/ 64) {
				set_style(button, "text-align", /*rtl*/ ctx[6] ? "right" : "left");
			}

			if (!current || dirty[0] & /*layout, bubble_full_width*/ 17408) {
				toggle_class(div0, "message-fit", /*layout*/ ctx[14] === "bubble" && !/*bubble_full_width*/ ctx[10]);
			}

			if (!current || dirty[0] & /*layout*/ 16384) {
				toggle_class(div0, "panel-full-width", /*layout*/ ctx[14] === "panel");
			}

			if (!current || dirty[0] & /*layout*/ 16384) {
				toggle_class(div0, "message-bubble-border", /*layout*/ ctx[14] === "bubble");
			}

			if (!current || dirty[0] & /*render_markdown*/ 2048) {
				toggle_class(div0, "message-markdown-disabled", !/*render_markdown*/ ctx[11]);
			}

			if (dirty[0] & /*rtl*/ 64) {
				set_style(div0, "text-align", /*rtl*/ ctx[6] && /*j*/ ctx[40] == 0 ? "left" : "right");
			}

			if (/*likeable*/ ctx[4] && /*j*/ ctx[40] !== 0 || /*show_copy_button*/ ctx[7] && /*message*/ ctx[38] && typeof /*message*/ ctx[38] === "string") {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*likeable, show_copy_button, value*/ 145) {
						transition_in$1(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_3(ctx);
					if_block2.c();
					transition_in$1(if_block2, 1);
					if_block2.m(div1, null);
				}
			} else if (if_block2) {
				group_outros$1();

				transition_out$1(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros$1();
			}

			if (!current || dirty[0] & /*layout*/ 16384 && div1_class_value !== (div1_class_value = "message-row " + /*layout*/ ctx[14] + " " + (/*j*/ ctx[40] == 0 ? 'user-row' : 'bot-row') + " svelte-1lcyrx4")) {
				attr$1(div1, "class", div1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block0);
			transition_in$1(if_block1);
			transition_in$1(if_block2);
			current = true;
		},
		o(local) {
			transition_out$1(if_block0);
			transition_out$1(if_block1);
			transition_out$1(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div1);
			}

			if (if_block0) if_block0.d();

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (119:7) {#if avatar_images[j] !== null}
function create_if_block_11(ctx) {
	let div_1;
	let image;
	let current;

	image = new Image({
			props: {
				class: "avatar-image",
				src: /*avatar_images*/ ctx[8][/*j*/ ctx[40]]?.url,
				alt: "" + ((/*j*/ ctx[40] == 0 ? 'user' : 'bot') + " avatar")
			}
		});

	return {
		c() {
			div_1 = element$1("div");
			create_component$1(image.$$.fragment);
			attr$1(div_1, "class", "avatar-container svelte-1lcyrx4");
		},
		m(target, anchor) {
			insert$1(target, div_1, anchor);
			mount_component$1(image, div_1, null);
			current = true;
		},
		p(ctx, dirty) {
			const image_changes = {};
			if (dirty[0] & /*avatar_images*/ 256) image_changes.src = /*avatar_images*/ ctx[8][/*j*/ ctx[40]]?.url;
			image.$set(image_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(image.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div_1);
			}

			destroy_component$1(image);
		}
	};
}

// (200:66) 
function create_if_block_10(ctx) {
	let a;
	let t_value = (/*message*/ ctx[38].file?.orig_name || /*message*/ ctx[38].file?.path) + "";
	let t;
	let a_href_value;
	let a_download_value;

	return {
		c() {
			a = element$1("a");
			t = text(t_value);
			attr$1(a, "data-testid", "chatbot-file");
			attr$1(a, "href", a_href_value = /*message*/ ctx[38].file?.url);
			attr$1(a, "target", "_blank");

			attr$1(a, "download", a_download_value = window.__is_colab__
			? null
			: /*message*/ ctx[38].file?.orig_name || /*message*/ ctx[38].file?.path);

			attr$1(a, "class", "svelte-1lcyrx4");
		},
		m(target, anchor) {
			insert$1(target, a, anchor);
			append$1(a, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && t_value !== (t_value = (/*message*/ ctx[38].file?.orig_name || /*message*/ ctx[38].file?.path) + "")) set_data(t, t_value);

			if (dirty[0] & /*value*/ 1 && a_href_value !== (a_href_value = /*message*/ ctx[38].file?.url)) {
				attr$1(a, "href", a_href_value);
			}

			if (dirty[0] & /*value*/ 1 && a_download_value !== (a_download_value = window.__is_colab__
			? null
			: /*message*/ ctx[38].file?.orig_name || /*message*/ ctx[38].file?.path)) {
				attr$1(a, "download", a_download_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach$1(a);
			}
		}
	};
}

// (194:82) 
function create_if_block_9(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				"data-testid": "chatbot-image",
				src: /*message*/ ctx[38].file?.url,
				alt: /*message*/ ctx[38].alt_text
			}
		});

	return {
		c() {
			create_component$1(image.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(image, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const image_changes = {};
			if (dirty[0] & /*value*/ 1) image_changes.src = /*message*/ ctx[38].file?.url;
			if (dirty[0] & /*value*/ 1) image_changes.alt = /*message*/ ctx[38].alt_text;
			image.$set(image_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(image.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(image, detaching);
		}
	};
}

// (181:82) 
function create_if_block_8(ctx) {
	let video;
	let current;

	video = new Video({
			props: {
				"data-testid": "chatbot-video",
				controls: true,
				src: /*message*/ ctx[38].file?.url,
				title: /*message*/ ctx[38].alt_text,
				preload: "auto",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	video.$on("play", /*play_handler_1*/ ctx[26]);
	video.$on("pause", /*pause_handler_1*/ ctx[27]);
	video.$on("ended", /*ended_handler_1*/ ctx[28]);

	return {
		c() {
			create_component$1(video.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(video, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const video_changes = {};
			if (dirty[0] & /*value*/ 1) video_changes.src = /*message*/ ctx[38].file?.url;
			if (dirty[0] & /*value*/ 1) video_changes.title = /*message*/ ctx[38].alt_text;

			if (dirty[1] & /*$$scope*/ 1024) {
				video_changes.$$scope = { dirty, ctx };
			}

			video.$set(video_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(video.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(video.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(video, detaching);
		}
	};
}

// (170:82) 
function create_if_block_7(ctx) {
	let audio;
	let current;

	audio = new Audio({
			props: {
				"data-testid": "chatbot-audio",
				controls: true,
				preload: "metadata",
				src: /*message*/ ctx[38].file?.url,
				title: /*message*/ ctx[38].alt_text
			}
		});

	audio.$on("play", /*play_handler*/ ctx[23]);
	audio.$on("pause", /*pause_handler*/ ctx[24]);
	audio.$on("ended", /*ended_handler*/ ctx[25]);

	return {
		c() {
			create_component$1(audio.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(audio, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const audio_changes = {};
			if (dirty[0] & /*value*/ 1) audio_changes.src = /*message*/ ctx[38].file?.url;
			if (dirty[0] & /*value*/ 1) audio_changes.title = /*message*/ ctx[38].alt_text;
			audio.$set(audio_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(audio.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(audio.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(audio, detaching);
		}
	};
}

// (161:9) {#if typeof message === "string"}
function create_if_block_6(ctx) {
	let markdown;
	let current;

	markdown = new MarkdownCode({
			props: {
				message: /*message*/ ctx[38],
				latex_delimiters: /*latex_delimiters*/ ctx[1],
				sanitize_html: /*sanitize_html*/ ctx[9],
				render_markdown: /*render_markdown*/ ctx[11],
				line_breaks: /*line_breaks*/ ctx[12]
			}
		});

	markdown.$on("load", /*scroll*/ ctx[16]);

	return {
		c() {
			create_component$1(markdown.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(markdown, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const markdown_changes = {};
			if (dirty[0] & /*value*/ 1) markdown_changes.message = /*message*/ ctx[38];
			if (dirty[0] & /*latex_delimiters*/ 2) markdown_changes.latex_delimiters = /*latex_delimiters*/ ctx[1];
			if (dirty[0] & /*sanitize_html*/ 512) markdown_changes.sanitize_html = /*sanitize_html*/ ctx[9];
			if (dirty[0] & /*render_markdown*/ 2048) markdown_changes.render_markdown = /*render_markdown*/ ctx[11];
			if (dirty[0] & /*line_breaks*/ 4096) markdown_changes.line_breaks = /*line_breaks*/ ctx[12];
			markdown.$set(markdown_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(markdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(markdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(markdown, detaching);
		}
	};
}

// (182:10) <Video            data-testid="chatbot-video"            controls            src={message.file?.url}            title={message.alt_text}            preload="auto"            on:play            on:pause            on:ended           >
function create_default_slot$1(ctx) {
	let track;

	return {
		c() {
			track = element$1("track");
			attr$1(track, "kind", "captions");
			attr$1(track, "class", "svelte-1lcyrx4");
		},
		m(target, anchor) {
			insert$1(target, track, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach$1(track);
			}
		}
	};
}

// (214:7) {#if (likeable && j !== 0) || (show_copy_button && message && typeof message === "string")}
function create_if_block_3(ctx) {
	let div_1;
	let t;
	let div_1_class_value;
	let current;
	let if_block0 = /*likeable*/ ctx[4] && /*j*/ ctx[40] == 1 && create_if_block_5(ctx);
	let if_block1 = /*show_copy_button*/ ctx[7] && /*message*/ ctx[38] && typeof /*message*/ ctx[38] === "string" && create_if_block_4(ctx);

	return {
		c() {
			div_1 = element$1("div");
			if (if_block0) if_block0.c();
			t = space$1();
			if (if_block1) if_block1.c();
			attr$1(div_1, "class", div_1_class_value = "message-buttons-" + (/*j*/ ctx[40] == 0 ? 'user' : 'bot') + " message-buttons-" + /*layout*/ ctx[14] + " " + (/*avatar_images*/ ctx[8][/*j*/ ctx[40]] !== null && 'with-avatar') + " svelte-1lcyrx4");
			toggle_class(div_1, "message-buttons-fit", /*layout*/ ctx[14] === "bubble" && !/*bubble_full_width*/ ctx[10]);
			toggle_class(div_1, "bubble-buttons-user", /*layout*/ ctx[14] === "bubble");
		},
		m(target, anchor) {
			insert$1(target, div_1, anchor);
			if (if_block0) if_block0.m(div_1, null);
			append$1(div_1, t);
			if (if_block1) if_block1.m(div_1, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*likeable*/ ctx[4] && /*j*/ ctx[40] == 1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*likeable*/ 16) {
						transition_in$1(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_5(ctx);
					if_block0.c();
					transition_in$1(if_block0, 1);
					if_block0.m(div_1, t);
				}
			} else if (if_block0) {
				group_outros$1();

				transition_out$1(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$1();
			}

			if (/*show_copy_button*/ ctx[7] && /*message*/ ctx[38] && typeof /*message*/ ctx[38] === "string") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*show_copy_button, value*/ 129) {
						transition_in$1(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_4(ctx);
					if_block1.c();
					transition_in$1(if_block1, 1);
					if_block1.m(div_1, null);
				}
			} else if (if_block1) {
				group_outros$1();

				transition_out$1(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros$1();
			}

			if (!current || dirty[0] & /*layout, avatar_images*/ 16640 && div_1_class_value !== (div_1_class_value = "message-buttons-" + (/*j*/ ctx[40] == 0 ? 'user' : 'bot') + " message-buttons-" + /*layout*/ ctx[14] + " " + (/*avatar_images*/ ctx[8][/*j*/ ctx[40]] !== null && 'with-avatar') + " svelte-1lcyrx4")) {
				attr$1(div_1, "class", div_1_class_value);
			}

			if (!current || dirty[0] & /*layout, avatar_images, layout, bubble_full_width*/ 17664) {
				toggle_class(div_1, "message-buttons-fit", /*layout*/ ctx[14] === "bubble" && !/*bubble_full_width*/ ctx[10]);
			}

			if (!current || dirty[0] & /*layout, avatar_images, layout*/ 16640) {
				toggle_class(div_1, "bubble-buttons-user", /*layout*/ ctx[14] === "bubble");
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block0);
			transition_in$1(if_block1);
			current = true;
		},
		o(local) {
			transition_out$1(if_block0);
			transition_out$1(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div_1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (224:9) {#if likeable && j == 1}
function create_if_block_5(ctx) {
	let likedislike;
	let current;

	function func(...args) {
		return /*func*/ ctx[31](/*i*/ ctx[37], /*j*/ ctx[40], /*message*/ ctx[38], ...args);
	}

	likedislike = new LikeDislike({ props: { handle_action: func } });

	return {
		c() {
			create_component$1(likedislike.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(likedislike, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const likedislike_changes = {};
			if (dirty[0] & /*value*/ 1) likedislike_changes.handle_action = func;
			likedislike.$set(likedislike_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(likedislike.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(likedislike.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(likedislike, detaching);
		}
	};
}

// (230:9) {#if show_copy_button && message && typeof message === "string"}
function create_if_block_4(ctx) {
	let copy_1;
	let current;
	copy_1 = new Copy_1({ props: { value: /*message*/ ctx[38] } });

	return {
		c() {
			create_component$1(copy_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(copy_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const copy_1_changes = {};
			if (dirty[0] & /*value*/ 1) copy_1_changes.value = /*message*/ ctx[38];
			copy_1.$set(copy_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(copy_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(copy_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(copy_1, detaching);
		}
	};
}

// (116:4) {#each message_pair as message, j}
function create_each_block_1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*message*/ ctx[38] !== null && create_if_block_2(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert$1(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*message*/ ctx[38] !== null) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*value*/ 1) {
						transition_in$1(if_block, 1);
					}
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					transition_in$1(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros$1();

				transition_out$1(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros$1();
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block);
			current = true;
		},
		o(local) {
			transition_out$1(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (115:3) {#each value as message_pair, i}
function create_each_block(ctx) {
	let each_1_anchor;
	let current;
	let each_value_1 = ensure_array_like(/*message_pair*/ ctx[35]);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out$1(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert$1(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*layout, avatar_images, bubble_full_width, value, show_copy_button, handle_like, likeable, render_markdown, rtl, selectable, handle_select, latex_delimiters, sanitize_html, line_breaks, scroll*/ 483291) {
				each_value_1 = ensure_array_like(/*message_pair*/ ctx[35]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in$1(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in$1(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros$1();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros$1();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in$1(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out$1(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (239:3) {#if pending_message}
function create_if_block_1$1(ctx) {
	let pending;
	let current;
	pending = new Pending({ props: { layout: /*layout*/ ctx[14] } });

	return {
		c() {
			create_component$1(pending.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(pending, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const pending_changes = {};
			if (dirty[0] & /*layout*/ 16384) pending_changes.layout = /*layout*/ ctx[14];
			pending.$set(pending_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(pending.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(pending.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(pending, detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let t;
	let div1;
	let div0;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*show_share_button*/ ctx[5] && /*value*/ ctx[0] !== null && /*value*/ ctx[0].length > 0 && create_if_block_12(ctx);
	let if_block1 = /*value*/ ctx[0] !== null && create_if_block$1(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space$1();
			div1 = element$1("div");
			div0 = element$1("div");
			if (if_block1) if_block1.c();
			attr$1(div0, "class", "message-wrap svelte-1lcyrx4");
			toggle_class(div0, "bubble-gap", /*layout*/ ctx[14] === "bubble");

			attr$1(div1, "class", div1_class_value = "" + (null_to_empty(/*layout*/ ctx[14] === "bubble"
			? "bubble-wrap"
			: "panel-wrap") + " svelte-1lcyrx4"));

			attr$1(div1, "role", "log");
			attr$1(div1, "aria-label", "chatbot conversation");
			attr$1(div1, "aria-live", "polite");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert$1(target, t, anchor);
			insert$1(target, div1, anchor);
			append$1(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			/*div1_binding*/ ctx[32](div1);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(copy.call(null, div0));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*show_share_button*/ ctx[5] && /*value*/ ctx[0] !== null && /*value*/ ctx[0].length > 0) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*show_share_button, value*/ 33) {
						transition_in$1(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_12(ctx);
					if_block0.c();
					transition_in$1(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros$1();

				transition_out$1(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$1();
			}

			if (/*value*/ ctx[0] !== null) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*value*/ 1) {
						transition_in$1(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in$1(if_block1, 1);
					if_block1.m(div0, null);
				}
			} else if (if_block1) {
				group_outros$1();

				transition_out$1(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros$1();
			}

			if (!current || dirty[0] & /*layout*/ 16384) {
				toggle_class(div0, "bubble-gap", /*layout*/ ctx[14] === "bubble");
			}

			if (!current || dirty[0] & /*layout*/ 16384 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*layout*/ ctx[14] === "bubble"
			? "bubble-wrap"
			: "panel-wrap") + " svelte-1lcyrx4"))) {
				attr$1(div1, "class", div1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block0);
			transition_in$1(if_block1);
			current = true;
		},
		o(local) {
			transition_out$1(if_block0);
			transition_out$1(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(t);
				detach$1(div1);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d();
			/*div1_binding*/ ctx[32](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let adjust_text_size;
	let { value } = $$props;
	let old_value = null;
	let { latex_delimiters } = $$props;
	let { pending_message = false } = $$props;
	let { selectable = false } = $$props;
	let { likeable = false } = $$props;
	let { show_share_button = false } = $$props;
	let { rtl = false } = $$props;
	let { show_copy_button = false } = $$props;
	let { avatar_images = [null, null] } = $$props;
	let { sanitize_html = true } = $$props;
	let { bubble_full_width = true } = $$props;
	let { render_markdown = true } = $$props;
	let { line_breaks = true } = $$props;
	let { i18n } = $$props;
	let { layout = "bubble" } = $$props;
	let div;
	let autoscroll;
	const dispatch = createEventDispatcher();

	beforeUpdate(() => {
		autoscroll = div && div.offsetHeight + div.scrollTop > div.scrollHeight - 100;
	});

	const scroll = () => {
		if (autoscroll) {
			div.scrollTo(0, div.scrollHeight);
		}
	};

	afterUpdate(() => {
		if (autoscroll) {
			scroll();

			div.querySelectorAll("img").forEach(n => {
				n.addEventListener("load", () => {
					scroll();
				});
			});
		}
	});

	function handle_select(i, j, message) {
		dispatch("select", { index: [i, j], value: message });
	}

	function handle_like(i, j, message, selected) {
		dispatch("like", {
			index: [i, j],
			value: message,
			liked: selected === "like"
		});
	}

	function error_handler(event) {
		bubble.call(this, $$self, event);
	}

	function share_handler(event) {
		bubble.call(this, $$self, event);
	}

	function play_handler(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler(event) {
		bubble.call(this, $$self, event);
	}

	function ended_handler(event) {
		bubble.call(this, $$self, event);
	}

	function play_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function pause_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function ended_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler = (i, j, message) => handle_select(i, j, message);

	const keydown_handler = (i, j, message, e) => {
		if (e.key === "Enter") {
			handle_select(i, j, message);
		}
	};

	const func = (i, j, message, selected) => handle_like(i, j, message, selected);

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			div = $$value;
			$$invalidate(15, div);
		});
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('latex_delimiters' in $$props) $$invalidate(1, latex_delimiters = $$props.latex_delimiters);
		if ('pending_message' in $$props) $$invalidate(2, pending_message = $$props.pending_message);
		if ('selectable' in $$props) $$invalidate(3, selectable = $$props.selectable);
		if ('likeable' in $$props) $$invalidate(4, likeable = $$props.likeable);
		if ('show_share_button' in $$props) $$invalidate(5, show_share_button = $$props.show_share_button);
		if ('rtl' in $$props) $$invalidate(6, rtl = $$props.rtl);
		if ('show_copy_button' in $$props) $$invalidate(7, show_copy_button = $$props.show_copy_button);
		if ('avatar_images' in $$props) $$invalidate(8, avatar_images = $$props.avatar_images);
		if ('sanitize_html' in $$props) $$invalidate(9, sanitize_html = $$props.sanitize_html);
		if ('bubble_full_width' in $$props) $$invalidate(10, bubble_full_width = $$props.bubble_full_width);
		if ('render_markdown' in $$props) $$invalidate(11, render_markdown = $$props.render_markdown);
		if ('line_breaks' in $$props) $$invalidate(12, line_breaks = $$props.line_breaks);
		if ('i18n' in $$props) $$invalidate(13, i18n = $$props.i18n);
		if ('layout' in $$props) $$invalidate(14, layout = $$props.layout);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*adjust_text_size*/ 1048576) {
			adjust_text_size();
		}

		if ($$self.$$.dirty[0] & /*value, old_value*/ 524289) {
			{
				if (!dequal(value, old_value)) {
					$$invalidate(19, old_value = value);
					dispatch("change");
				}
			}
		}
	};

	$$invalidate(20, adjust_text_size = () => {
		let style = getComputedStyle(document.body);
		let body_text_size = style.getPropertyValue("--body-text-size");
		let updated_text_size;

		switch (body_text_size) {
			case "13px":
				updated_text_size = 14;
				break;
			case "14px":
				updated_text_size = 16;
				break;
			case "16px":
				updated_text_size = 20;
				break;
			default:
				updated_text_size = 14;
				break;
		}

		document.body.style.setProperty("--chatbot-body-text-size", updated_text_size + "px");
	});

	return [
		value,
		latex_delimiters,
		pending_message,
		selectable,
		likeable,
		show_share_button,
		rtl,
		show_copy_button,
		avatar_images,
		sanitize_html,
		bubble_full_width,
		render_markdown,
		line_breaks,
		i18n,
		layout,
		div,
		scroll,
		handle_select,
		handle_like,
		old_value,
		adjust_text_size,
		error_handler,
		share_handler,
		play_handler,
		pause_handler,
		ended_handler,
		play_handler_1,
		pause_handler_1,
		ended_handler_1,
		click_handler,
		keydown_handler,
		func,
		div1_binding
	];
}

class ChatBot extends SvelteComponent$1 {
	constructor(options) {
		super();

		init$1(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal$1,
			{
				value: 0,
				latex_delimiters: 1,
				pending_message: 2,
				selectable: 3,
				likeable: 4,
				show_share_button: 5,
				rtl: 6,
				show_copy_button: 7,
				avatar_images: 8,
				sanitize_html: 9,
				bubble_full_width: 10,
				render_markdown: 11,
				line_breaks: 12,
				i18n: 13,
				layout: 14
			},
			null,
			[-1, -1]
		);
	}
}

const ChatBot$1 = ChatBot;

const Index_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/chatbot/Index.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent,
	append,
	assign,
	attr,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	get_spread_object,
	get_spread_update,
	group_outros,
	init,
	insert,
	mount_component,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} = window.__gradio__svelte__internal;
function create_if_block_1(ctx) {
	let statustracker;
	let current;

	const statustracker_spread_levels = [
		{
			autoscroll: /*gradio*/ ctx[19].autoscroll
		},
		{ i18n: /*gradio*/ ctx[19].i18n },
		/*loading_status*/ ctx[21],
		{
			show_progress: /*loading_status*/ ctx[21].show_progress === "hidden"
			? "hidden"
			: "minimal"
		}
	];

	let statustracker_props = {};

	for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
		statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
	}

	statustracker = new Static({ props: statustracker_props });

	return {
		c() {
			create_component(statustracker.$$.fragment);
		},
		m(target, anchor) {
			mount_component(statustracker, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const statustracker_changes = (dirty[0] & /*gradio, loading_status*/ 2621440)
			? get_spread_update(statustracker_spread_levels, [
					dirty[0] & /*gradio*/ 524288 && {
						autoscroll: /*gradio*/ ctx[19].autoscroll
					},
					dirty[0] & /*gradio*/ 524288 && { i18n: /*gradio*/ ctx[19].i18n },
					dirty[0] & /*loading_status*/ 2097152 && get_spread_object(/*loading_status*/ ctx[21]),
					dirty[0] & /*loading_status*/ 2097152 && {
						show_progress: /*loading_status*/ ctx[21].show_progress === "hidden"
						? "hidden"
						: "minimal"
					}
				])
			: {};

			statustracker.$set(statustracker_changes);
		},
		i(local) {
			if (current) return;
			transition_in(statustracker.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(statustracker.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(statustracker, detaching);
		}
	};
}

// (76:2) {#if show_label}
function create_if_block(ctx) {
	let blocklabel;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[7],
				Icon: Chat,
				float: false,
				label: /*label*/ ctx[6] || "Chatbot"
			}
		});

	return {
		c() {
			create_component(blocklabel.$$.fragment);
		},
		m(target, anchor) {
			mount_component(blocklabel, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const blocklabel_changes = {};
			if (dirty[0] & /*show_label*/ 128) blocklabel_changes.show_label = /*show_label*/ ctx[7];
			if (dirty[0] & /*label*/ 64) blocklabel_changes.label = /*label*/ ctx[6] || "Chatbot";
			blocklabel.$set(blocklabel_changes);
		},
		i(local) {
			if (current) return;
			transition_in(blocklabel.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(blocklabel.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(blocklabel, detaching);
		}
	};
}

// (55:0) <Block  {elem_id}  {elem_classes}  {visible}  padding={false}  {scale}  {min_width}  {height}  allow_overflow={false} >
function create_default_slot(ctx) {
	let t0;
	let div;
	let t1;
	let chatbot;
	let current;
	let if_block0 = /*loading_status*/ ctx[21] && create_if_block_1(ctx);
	let if_block1 = /*show_label*/ ctx[7] && create_if_block(ctx);

	chatbot = new ChatBot$1({
			props: {
				i18n: /*gradio*/ ctx[19].i18n,
				selectable: /*_selectable*/ ctx[8],
				likeable: /*likeable*/ ctx[9],
				show_share_button: /*show_share_button*/ ctx[10],
				value: /*_value*/ ctx[23],
				latex_delimiters: /*latex_delimiters*/ ctx[18],
				render_markdown: /*render_markdown*/ ctx[16],
				pending_message: /*loading_status*/ ctx[21]?.status === "pending",
				rtl: /*rtl*/ ctx[11],
				show_copy_button: /*show_copy_button*/ ctx[12],
				avatar_images: /*avatar_images*/ ctx[20],
				sanitize_html: /*sanitize_html*/ ctx[13],
				bubble_full_width: /*bubble_full_width*/ ctx[14],
				line_breaks: /*line_breaks*/ ctx[17],
				layout: /*layout*/ ctx[15]
			}
		});

	chatbot.$on("change", /*change_handler*/ ctx[25]);
	chatbot.$on("select", /*select_handler*/ ctx[26]);
	chatbot.$on("like", /*like_handler*/ ctx[27]);
	chatbot.$on("share", /*share_handler*/ ctx[28]);
	chatbot.$on("error", /*error_handler*/ ctx[29]);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			create_component(chatbot.$$.fragment);
			attr(div, "class", "wrapper svelte-nab2ao");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, div, anchor);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);
			mount_component(chatbot, div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*loading_status*/ ctx[21]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*loading_status*/ 2097152) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*show_label*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*show_label*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const chatbot_changes = {};
			if (dirty[0] & /*gradio*/ 524288) chatbot_changes.i18n = /*gradio*/ ctx[19].i18n;
			if (dirty[0] & /*_selectable*/ 256) chatbot_changes.selectable = /*_selectable*/ ctx[8];
			if (dirty[0] & /*likeable*/ 512) chatbot_changes.likeable = /*likeable*/ ctx[9];
			if (dirty[0] & /*show_share_button*/ 1024) chatbot_changes.show_share_button = /*show_share_button*/ ctx[10];
			if (dirty[0] & /*_value*/ 8388608) chatbot_changes.value = /*_value*/ ctx[23];
			if (dirty[0] & /*latex_delimiters*/ 262144) chatbot_changes.latex_delimiters = /*latex_delimiters*/ ctx[18];
			if (dirty[0] & /*render_markdown*/ 65536) chatbot_changes.render_markdown = /*render_markdown*/ ctx[16];
			if (dirty[0] & /*loading_status*/ 2097152) chatbot_changes.pending_message = /*loading_status*/ ctx[21]?.status === "pending";
			if (dirty[0] & /*rtl*/ 2048) chatbot_changes.rtl = /*rtl*/ ctx[11];
			if (dirty[0] & /*show_copy_button*/ 4096) chatbot_changes.show_copy_button = /*show_copy_button*/ ctx[12];
			if (dirty[0] & /*avatar_images*/ 1048576) chatbot_changes.avatar_images = /*avatar_images*/ ctx[20];
			if (dirty[0] & /*sanitize_html*/ 8192) chatbot_changes.sanitize_html = /*sanitize_html*/ ctx[13];
			if (dirty[0] & /*bubble_full_width*/ 16384) chatbot_changes.bubble_full_width = /*bubble_full_width*/ ctx[14];
			if (dirty[0] & /*line_breaks*/ 131072) chatbot_changes.line_breaks = /*line_breaks*/ ctx[17];
			if (dirty[0] & /*layout*/ 32768) chatbot_changes.layout = /*layout*/ ctx[15];
			chatbot.$set(chatbot_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(chatbot.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(chatbot.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(div);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d();
			destroy_component(chatbot);
		}
	};
}

function create_fragment(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				elem_id: /*elem_id*/ ctx[0],
				elem_classes: /*elem_classes*/ ctx[1],
				visible: /*visible*/ ctx[2],
				padding: false,
				scale: /*scale*/ ctx[4],
				min_width: /*min_width*/ ctx[5],
				height: /*height*/ ctx[22],
				allow_overflow: false,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(block.$$.fragment);
		},
		m(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const block_changes = {};
			if (dirty[0] & /*elem_id*/ 1) block_changes.elem_id = /*elem_id*/ ctx[0];
			if (dirty[0] & /*elem_classes*/ 2) block_changes.elem_classes = /*elem_classes*/ ctx[1];
			if (dirty[0] & /*visible*/ 4) block_changes.visible = /*visible*/ ctx[2];
			if (dirty[0] & /*scale*/ 16) block_changes.scale = /*scale*/ ctx[4];
			if (dirty[0] & /*min_width*/ 32) block_changes.min_width = /*min_width*/ ctx[5];
			if (dirty[0] & /*height*/ 4194304) block_changes.height = /*height*/ ctx[22];

			if (dirty[0] & /*gradio, _selectable, likeable, show_share_button, _value, latex_delimiters, render_markdown, loading_status, rtl, show_copy_button, avatar_images, sanitize_html, bubble_full_width, line_breaks, layout, value, show_label, label*/ 12582856 | dirty[1] & /*$$scope*/ 1) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(block, detaching);
		}
	};
}

function normalize_messages(message) {
	if (message === null) {
		return message;
	}

	return {
		file: message?.file,
		alt_text: message?.alt_text
	};
}

function instance($$self, $$props, $$invalidate) {
	let { elem_id = "" } = $$props;
	let { elem_classes = [] } = $$props;
	let { visible = true } = $$props;
	let { value = [] } = $$props;
	let { scale = null } = $$props;
	let { min_width = undefined } = $$props;
	let { label } = $$props;
	let { show_label = true } = $$props;
	let { root } = $$props;
	let { _selectable = false } = $$props;
	let { likeable = false } = $$props;
	let { show_share_button = false } = $$props;
	let { rtl = false } = $$props;
	let { show_copy_button = false } = $$props;
	let { sanitize_html = true } = $$props;
	let { bubble_full_width = true } = $$props;
	let { layout = "bubble" } = $$props;
	let { render_markdown = true } = $$props;
	let { line_breaks = true } = $$props;
	let { latex_delimiters } = $$props;
	let { gradio } = $$props;
	let { avatar_images = [null, null] } = $$props;
	let _value;
	const redirect_src_url = src => src.replace('src="/file', `src="${root}file`);
	let { loading_status = undefined } = $$props;
	let { height = 400 } = $$props;
	const change_handler = () => gradio.dispatch("change", value);
	const select_handler = e => gradio.dispatch("select", e.detail);
	const like_handler = e => gradio.dispatch("like", e.detail);
	const share_handler = e => gradio.dispatch("share", e.detail);
	const error_handler = e => gradio.dispatch("error", e.detail);

	$$self.$$set = $$props => {
		if ('elem_id' in $$props) $$invalidate(0, elem_id = $$props.elem_id);
		if ('elem_classes' in $$props) $$invalidate(1, elem_classes = $$props.elem_classes);
		if ('visible' in $$props) $$invalidate(2, visible = $$props.visible);
		if ('value' in $$props) $$invalidate(3, value = $$props.value);
		if ('scale' in $$props) $$invalidate(4, scale = $$props.scale);
		if ('min_width' in $$props) $$invalidate(5, min_width = $$props.min_width);
		if ('label' in $$props) $$invalidate(6, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(7, show_label = $$props.show_label);
		if ('root' in $$props) $$invalidate(24, root = $$props.root);
		if ('_selectable' in $$props) $$invalidate(8, _selectable = $$props._selectable);
		if ('likeable' in $$props) $$invalidate(9, likeable = $$props.likeable);
		if ('show_share_button' in $$props) $$invalidate(10, show_share_button = $$props.show_share_button);
		if ('rtl' in $$props) $$invalidate(11, rtl = $$props.rtl);
		if ('show_copy_button' in $$props) $$invalidate(12, show_copy_button = $$props.show_copy_button);
		if ('sanitize_html' in $$props) $$invalidate(13, sanitize_html = $$props.sanitize_html);
		if ('bubble_full_width' in $$props) $$invalidate(14, bubble_full_width = $$props.bubble_full_width);
		if ('layout' in $$props) $$invalidate(15, layout = $$props.layout);
		if ('render_markdown' in $$props) $$invalidate(16, render_markdown = $$props.render_markdown);
		if ('line_breaks' in $$props) $$invalidate(17, line_breaks = $$props.line_breaks);
		if ('latex_delimiters' in $$props) $$invalidate(18, latex_delimiters = $$props.latex_delimiters);
		if ('gradio' in $$props) $$invalidate(19, gradio = $$props.gradio);
		if ('avatar_images' in $$props) $$invalidate(20, avatar_images = $$props.avatar_images);
		if ('loading_status' in $$props) $$invalidate(21, loading_status = $$props.loading_status);
		if ('height' in $$props) $$invalidate(22, height = $$props.height);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value*/ 8) {
			$$invalidate(23, _value = value
			? value.map(([user_msg, bot_msg]) => [
					typeof user_msg === "string"
					? redirect_src_url(user_msg)
					: normalize_messages(user_msg),
					typeof bot_msg === "string"
					? redirect_src_url(bot_msg)
					: normalize_messages(bot_msg)
				])
			: []);
		}
	};

	return [
		elem_id,
		elem_classes,
		visible,
		value,
		scale,
		min_width,
		label,
		show_label,
		_selectable,
		likeable,
		show_share_button,
		rtl,
		show_copy_button,
		sanitize_html,
		bubble_full_width,
		layout,
		render_markdown,
		line_breaks,
		latex_delimiters,
		gradio,
		avatar_images,
		loading_status,
		height,
		_value,
		root,
		change_handler,
		select_handler,
		like_handler,
		share_handler,
		error_handler
	];
}

class Index extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				elem_id: 0,
				elem_classes: 1,
				visible: 2,
				value: 3,
				scale: 4,
				min_width: 5,
				label: 6,
				show_label: 7,
				root: 24,
				_selectable: 8,
				likeable: 9,
				show_share_button: 10,
				rtl: 11,
				show_copy_button: 12,
				sanitize_html: 13,
				bubble_full_width: 14,
				layout: 15,
				render_markdown: 16,
				line_breaks: 17,
				latex_delimiters: 18,
				gradio: 19,
				avatar_images: 20,
				loading_status: 21,
				height: 22
			},
			null,
			[-1, -1]
		);
	}
}

export { ChatBot$1 as BaseChatBot, Index as default };
//# sourceMappingURL=Index-912feb3b.js.map
