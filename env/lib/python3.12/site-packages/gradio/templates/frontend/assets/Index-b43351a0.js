import { B as Block } from './Button-bd009e9a.js';
import { S as Static } from './Index-7fdff9d2.js';
import { U as UploadText } from './UploadText-f0b99b38.js';
import { B as BlockLabel } from './BlockLabel-5d99d786.js';
import { I as IconButton } from './IconButton-9a708715.js';
import { E as Empty } from './Empty-dc0720f3.js';
import { S as ShareButton } from './ShareButton-5feea5fe.js';
import { a as Download } from './DownloadLink-e3ba8890.js';
import { I as Image } from './Image-6cbf81d1.js';
import './index-10ead756.js';
import './ModifyUpload.svelte_svelte_type_style_lang-3e24959e.js';
import { M as ModifyUpload } from './ModifyUpload-3536306b.js';
import { I as Image$1 } from './Image-e7664ad6.js';
import { u as uploadToHuggingFace } from './utils-013c0d40.js';
import { B as BaseFileUpload } from './FileUpload-b86d6791.js';
/* empty css                                                */import './Upload-96564545.js';
import './file-url-6213a515.js';
import './svelte/svelte.js';
import './Undo-6c110254.js';
import './File-e96cd7d6.js';

var has = Object.prototype.hasOwnProperty;

function find(iter, tar, key) {
	for (key of iter.keys()) {
		if (dequal(key, tar)) return key;
	}
}

function dequal(foo, bar) {
	var ctor, len, tmp;
	if (foo === bar) return true;

	if (foo && bar && (ctor=foo.constructor) === bar.constructor) {
		if (ctor === Date) return foo.getTime() === bar.getTime();
		if (ctor === RegExp) return foo.toString() === bar.toString();

		if (ctor === Array) {
			if ((len=foo.length) === bar.length) {
				while (len-- && dequal(foo[len], bar[len]));
			}
			return len === -1;
		}

		if (ctor === Set) {
			if (foo.size !== bar.size) {
				return false;
			}
			for (len of foo) {
				tmp = len;
				if (tmp && typeof tmp === 'object') {
					tmp = find(bar, tmp);
					if (!tmp) return false;
				}
				if (!bar.has(tmp)) return false;
			}
			return true;
		}

		if (ctor === Map) {
			if (foo.size !== bar.size) {
				return false;
			}
			for (len of foo) {
				tmp = len[0];
				if (tmp && typeof tmp === 'object') {
					tmp = find(bar, tmp);
					if (!tmp) return false;
				}
				if (!dequal(len[1], bar.get(tmp))) {
					return false;
				}
			}
			return true;
		}

		if (ctor === ArrayBuffer) {
			foo = new Uint8Array(foo);
			bar = new Uint8Array(bar);
		} else if (ctor === DataView) {
			if ((len=foo.byteLength) === bar.byteLength) {
				while (len-- && foo.getInt8(len) === bar.getInt8(len));
			}
			return len === -1;
		}

		if (ArrayBuffer.isView(foo)) {
			if ((len=foo.byteLength) === bar.byteLength) {
				while (len-- && foo[len] === bar[len]);
			}
			return len === -1;
		}

		if (!ctor || typeof foo === 'object') {
			len = 0;
			for (ctor in foo) {
				if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
				if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
			}
			return Object.keys(bar).length === len;
		}
	}

	return foo !== foo && bar !== bar;
}

async function format_gallery_for_sharing(value) {
  if (!value)
    return "";
  let urls = await Promise.all(
    value.map(async ([image, _]) => {
      if (image === null || !image.url)
        return "";
      return await uploadToHuggingFace(image.url, "url");
    })
  );
  return `<div style="display: flex; flex-wrap: wrap; gap: 16px">${urls.map((url) => `<img src="${url}" style="height: 400px" />`).join("")}</div>`;
}

const Gallery_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/gallery/shared/Gallery.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$1,
	add_iframe_resize_listener,
	add_render_callback,
	append,
	attr,
	binding_callbacks: binding_callbacks$1,
	bubble,
	check_outros: check_outros$1,
	create_component: create_component$1,
	destroy_component: destroy_component$1,
	destroy_each,
	detach: detach$1,
	element,
	empty: empty$1,
	ensure_array_like,
	globals,
	group_outros: group_outros$1,
	init: init$1,
	insert: insert$1,
	listen,
	mount_component: mount_component$1,
	run_all,
	safe_not_equal: safe_not_equal$1,
	set_data,
	set_style,
	space: space$1,
	text,
	toggle_class,
	transition_in: transition_in$1,
	transition_out: transition_out$1
} = window.__gradio__svelte__internal;
const { window: window_1 } = globals;
const { createEventDispatcher: createEventDispatcher$1, getContext } = window.__gradio__svelte__internal;const { tick } = window.__gradio__svelte__internal;
function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[43] = list[i];
	child_ctx[45] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[46] = list[i];
	child_ctx[47] = list;
	child_ctx[45] = i;
	return child_ctx;
}

// (169:0) {#if show_label}
function create_if_block_7(ctx) {
	let blocklabel;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[2],
				Icon: Image,
				label: /*label*/ ctx[3] || "Gallery"
			}
		});

	return {
		c() {
			create_component$1(blocklabel.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(blocklabel, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const blocklabel_changes = {};
			if (dirty[0] & /*show_label*/ 4) blocklabel_changes.show_label = /*show_label*/ ctx[2];
			if (dirty[0] & /*label*/ 8) blocklabel_changes.label = /*label*/ ctx[3] || "Gallery";
			blocklabel.$set(blocklabel_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(blocklabel.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(blocklabel.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(blocklabel, detaching);
		}
	};
}

// (174:0) {:else}
function create_else_block$1(ctx) {
	let t0;
	let div1;
	let div0;
	let t1;
	let t2;
	let div1_resize_listener;
	let current;
	let if_block0 = /*selected_image*/ ctx[18] && /*allow_preview*/ ctx[7] && create_if_block_4(ctx);
	let if_block1 = /*interactive*/ ctx[12] && create_if_block_3(ctx);
	let if_block2 = /*show_share_button*/ ctx[9] && create_if_block_2(ctx);
	let each_value = ensure_array_like(/*resolved_value*/ ctx[13]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out$1(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space$1();
			div1 = element("div");
			div0 = element("div");
			if (if_block1) if_block1.c();
			t1 = space$1();
			if (if_block2) if_block2.c();
			t2 = space$1();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", "grid-container svelte-hpz95u");
			set_style(div0, "--grid-cols", /*columns*/ ctx[4]);
			set_style(div0, "--grid-rows", /*rows*/ ctx[5]);
			set_style(div0, "--object-fit", /*object_fit*/ ctx[8]);
			set_style(div0, "height", /*height*/ ctx[6]);
			toggle_class(div0, "pt-6", /*show_label*/ ctx[2]);
			attr(div1, "class", "grid-wrap svelte-hpz95u");
			add_render_callback(() => /*div1_elementresize_handler*/ ctx[37].call(div1));
			toggle_class(div1, "fixed-height", !/*height*/ ctx[6] || /*height*/ ctx[6] == "auto");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert$1(target, t0, anchor);
			insert$1(target, div1, anchor);
			append(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			append(div0, t1);
			if (if_block2) if_block2.m(div0, null);
			append(div0, t2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}

			div1_resize_listener = add_iframe_resize_listener(div1, /*div1_elementresize_handler*/ ctx[37].bind(div1));
			current = true;
		},
		p(ctx, dirty) {
			if (/*selected_image*/ ctx[18] && /*allow_preview*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*selected_image, allow_preview*/ 262272) {
						transition_in$1(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in$1(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros$1();

				transition_out$1(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$1();
			}

			if (/*interactive*/ ctx[12]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*interactive*/ 4096) {
						transition_in$1(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					transition_in$1(if_block1, 1);
					if_block1.m(div0, t1);
				}
			} else if (if_block1) {
				group_outros$1();

				transition_out$1(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros$1();
			}

			if (/*show_share_button*/ ctx[9]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*show_share_button*/ 512) {
						transition_in$1(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_2(ctx);
					if_block2.c();
					transition_in$1(if_block2, 1);
					if_block2.m(div0, t2);
				}
			} else if (if_block2) {
				group_outros$1();

				transition_out$1(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros$1();
			}

			if (dirty[0] & /*resolved_value, selected_index*/ 8194) {
				each_value = ensure_array_like(/*resolved_value*/ ctx[13]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in$1(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in$1(each_blocks[i], 1);
						each_blocks[i].m(div0, null);
					}
				}

				group_outros$1();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros$1();
			}

			if (!current || dirty[0] & /*columns*/ 16) {
				set_style(div0, "--grid-cols", /*columns*/ ctx[4]);
			}

			if (!current || dirty[0] & /*rows*/ 32) {
				set_style(div0, "--grid-rows", /*rows*/ ctx[5]);
			}

			if (!current || dirty[0] & /*object_fit*/ 256) {
				set_style(div0, "--object-fit", /*object_fit*/ ctx[8]);
			}

			if (!current || dirty[0] & /*height*/ 64) {
				set_style(div0, "height", /*height*/ ctx[6]);
			}

			if (!current || dirty[0] & /*show_label*/ 4) {
				toggle_class(div0, "pt-6", /*show_label*/ ctx[2]);
			}

			if (!current || dirty[0] & /*height*/ 64) {
				toggle_class(div1, "fixed-height", !/*height*/ ctx[6] || /*height*/ ctx[6] == "auto");
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block0);
			transition_in$1(if_block1);
			transition_in$1(if_block2);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in$1(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out$1(if_block0);
			transition_out$1(if_block1);
			transition_out$1(if_block2);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out$1(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(t0);
				detach$1(div1);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			destroy_each(each_blocks, detaching);
			div1_resize_listener();
		}
	};
}

// (172:0) {#if value == null || resolved_value == null || resolved_value.length === 0}
function create_if_block$1(ctx) {
	let empty_1;
	let current;

	empty_1 = new Empty({
			props: {
				unpadded_box: true,
				size: "large",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component$1(empty_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(empty_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const empty_1_changes = {};

			if (dirty[1] & /*$$scope*/ 131072) {
				empty_1_changes.$$scope = { dirty, ctx };
			}

			empty_1.$set(empty_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(empty_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(empty_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(empty_1, detaching);
		}
	};
}

// (175:1) {#if selected_image && allow_preview}
function create_if_block_4(ctx) {
	let button1;
	let div0;
	let t0;
	let modifyupload;
	let t1;
	let button0;
	let image_1;
	let t2;
	let t3;
	let div1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*show_download_button*/ ctx[10] && create_if_block_6(ctx);

	modifyupload = new ModifyUpload({
			props: { i18n: /*i18n*/ ctx[11], absolute: false }
		});

	modifyupload.$on("clear", /*clear_handler*/ ctx[28]);

	image_1 = new Image$1({
			props: {
				"data-testid": "detailed-image",
				src: /*selected_image*/ ctx[18].image.url,
				alt: /*selected_image*/ ctx[18].caption || "",
				title: /*selected_image*/ ctx[18].caption || null,
				class: /*selected_image*/ ctx[18].caption && "with-caption",
				loading: "lazy"
			}
		});

	let if_block1 = /*selected_image*/ ctx[18]?.caption && create_if_block_5(ctx);
	let each_value_1 = ensure_array_like(/*resolved_value*/ ctx[13]);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out$1(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			button1 = element("button");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t0 = space$1();
			create_component$1(modifyupload.$$.fragment);
			t1 = space$1();
			button0 = element("button");
			create_component$1(image_1.$$.fragment);
			t2 = space$1();
			if (if_block1) if_block1.c();
			t3 = space$1();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", "icon-buttons svelte-hpz95u");
			attr(button0, "class", "image-button svelte-hpz95u");
			set_style(button0, "height", "calc(100% - " + (/*selected_image*/ ctx[18].caption ? '80px' : '60px') + ")");
			attr(button0, "aria-label", "detailed view of selected image");
			attr(div1, "class", "thumbnails scroll-hide svelte-hpz95u");
			attr(div1, "data-testid", "container_el");
			attr(button1, "class", "preview svelte-hpz95u");
		},
		m(target, anchor) {
			insert$1(target, button1, anchor);
			append(button1, div0);
			if (if_block0) if_block0.m(div0, null);
			append(div0, t0);
			mount_component$1(modifyupload, div0, null);
			append(button1, t1);
			append(button1, button0);
			mount_component$1(image_1, button0, null);
			append(button1, t2);
			if (if_block1) if_block1.m(button1, null);
			append(button1, t3);
			append(button1, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div1, null);
				}
			}

			/*div1_binding*/ ctx[32](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*click_handler_1*/ ctx[29]),
					listen(button1, "keydown", /*on_keydown*/ ctx[20])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*show_download_button*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*show_download_button*/ 1024) {
						transition_in$1(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_6(ctx);
					if_block0.c();
					transition_in$1(if_block0, 1);
					if_block0.m(div0, t0);
				}
			} else if (if_block0) {
				group_outros$1();

				transition_out$1(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$1();
			}

			const modifyupload_changes = {};
			if (dirty[0] & /*i18n*/ 2048) modifyupload_changes.i18n = /*i18n*/ ctx[11];
			modifyupload.$set(modifyupload_changes);
			const image_1_changes = {};
			if (dirty[0] & /*selected_image*/ 262144) image_1_changes.src = /*selected_image*/ ctx[18].image.url;
			if (dirty[0] & /*selected_image*/ 262144) image_1_changes.alt = /*selected_image*/ ctx[18].caption || "";
			if (dirty[0] & /*selected_image*/ 262144) image_1_changes.title = /*selected_image*/ ctx[18].caption || null;
			if (dirty[0] & /*selected_image*/ 262144) image_1_changes.class = /*selected_image*/ ctx[18].caption && "with-caption";
			image_1.$set(image_1_changes);

			if (!current || dirty[0] & /*selected_image*/ 262144) {
				set_style(button0, "height", "calc(100% - " + (/*selected_image*/ ctx[18].caption ? '80px' : '60px') + ")");
			}

			if (/*selected_image*/ ctx[18]?.caption) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_5(ctx);
					if_block1.c();
					if_block1.m(button1, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*resolved_value, el, selected_index*/ 24578) {
				each_value_1 = ensure_array_like(/*resolved_value*/ ctx[13]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in$1(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in$1(each_blocks[i], 1);
						each_blocks[i].m(div1, null);
					}
				}

				group_outros$1();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros$1();
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block0);
			transition_in$1(modifyupload.$$.fragment, local);
			transition_in$1(image_1.$$.fragment, local);

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in$1(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out$1(if_block0);
			transition_out$1(modifyupload.$$.fragment, local);
			transition_out$1(image_1.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out$1(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(button1);
			}

			if (if_block0) if_block0.d();
			destroy_component$1(modifyupload);
			destroy_component$1(image_1);
			if (if_block1) if_block1.d();
			destroy_each(each_blocks, detaching);
			/*div1_binding*/ ctx[32](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (178:4) {#if show_download_button}
function create_if_block_6(ctx) {
	let div;
	let iconbutton;
	let current;

	iconbutton = new IconButton({
			props: {
				Icon: Download,
				label: /*i18n*/ ctx[11]("common.download")
			}
		});

	iconbutton.$on("click", /*click_handler*/ ctx[27]);

	return {
		c() {
			div = element("div");
			create_component$1(iconbutton.$$.fragment);
			attr(div, "class", "download-button-container svelte-hpz95u");
		},
		m(target, anchor) {
			insert$1(target, div, anchor);
			mount_component$1(iconbutton, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const iconbutton_changes = {};
			if (dirty[0] & /*i18n*/ 2048) iconbutton_changes.label = /*i18n*/ ctx[11]("common.download");
			iconbutton.$set(iconbutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(iconbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(iconbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div);
			}

			destroy_component$1(iconbutton);
		}
	};
}

// (218:3) {#if selected_image?.caption}
function create_if_block_5(ctx) {
	let caption;
	let t_value = /*selected_image*/ ctx[18].caption + "";
	let t;

	return {
		c() {
			caption = element("caption");
			t = text(t_value);
			attr(caption, "class", "caption svelte-hpz95u");
		},
		m(target, anchor) {
			insert$1(target, caption, anchor);
			append(caption, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*selected_image*/ 262144 && t_value !== (t_value = /*selected_image*/ ctx[18].caption + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach$1(caption);
			}
		}
	};
}

// (228:4) {#each resolved_value as image, i}
function create_each_block_1(ctx) {
	let button;
	let image_1;
	let t;
	let button_aria_label_value;
	let i = /*i*/ ctx[45];
	let current;
	let mounted;
	let dispose;

	image_1 = new Image$1({
			props: {
				src: /*image*/ ctx[46].image.url,
				title: /*image*/ ctx[46].caption || null,
				"data-testid": "thumbnail " + (/*i*/ ctx[45] + 1),
				alt: "",
				loading: "lazy"
			}
		});

	const assign_button = () => /*button_binding*/ ctx[30](button, i);
	const unassign_button = () => /*button_binding*/ ctx[30](null, i);

	function click_handler_2() {
		return /*click_handler_2*/ ctx[31](/*i*/ ctx[45]);
	}

	return {
		c() {
			button = element("button");
			create_component$1(image_1.$$.fragment);
			t = space$1();
			attr(button, "class", "thumbnail-item thumbnail-small svelte-hpz95u");
			attr(button, "aria-label", button_aria_label_value = "Thumbnail " + (/*i*/ ctx[45] + 1) + " of " + /*resolved_value*/ ctx[13].length);
			toggle_class(button, "selected", /*selected_index*/ ctx[1] === /*i*/ ctx[45]);
		},
		m(target, anchor) {
			insert$1(target, button, anchor);
			mount_component$1(image_1, button, null);
			append(button, t);
			assign_button();
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", click_handler_2);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const image_1_changes = {};
			if (dirty[0] & /*resolved_value*/ 8192) image_1_changes.src = /*image*/ ctx[46].image.url;
			if (dirty[0] & /*resolved_value*/ 8192) image_1_changes.title = /*image*/ ctx[46].caption || null;
			image_1.$set(image_1_changes);

			if (!current || dirty[0] & /*resolved_value*/ 8192 && button_aria_label_value !== (button_aria_label_value = "Thumbnail " + (/*i*/ ctx[45] + 1) + " of " + /*resolved_value*/ ctx[13].length)) {
				attr(button, "aria-label", button_aria_label_value);
			}

			if (i !== /*i*/ ctx[45]) {
				unassign_button();
				i = /*i*/ ctx[45];
				assign_button();
			}

			if (!current || dirty[0] & /*selected_index*/ 2) {
				toggle_class(button, "selected", /*selected_index*/ ctx[1] === /*i*/ ctx[45]);
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(image_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(image_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(button);
			}

			destroy_component$1(image_1);
			unassign_button();
			mounted = false;
			dispose();
		}
	};
}

// (259:3) {#if interactive}
function create_if_block_3(ctx) {
	let div;
	let modifyupload;
	let current;

	modifyupload = new ModifyUpload({
			props: { i18n: /*i18n*/ ctx[11], absolute: false }
		});

	modifyupload.$on("clear", /*clear_handler_1*/ ctx[33]);

	return {
		c() {
			div = element("div");
			create_component$1(modifyupload.$$.fragment);
			attr(div, "class", "icon-button svelte-hpz95u");
		},
		m(target, anchor) {
			insert$1(target, div, anchor);
			mount_component$1(modifyupload, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const modifyupload_changes = {};
			if (dirty[0] & /*i18n*/ 2048) modifyupload_changes.i18n = /*i18n*/ ctx[11];
			modifyupload.$set(modifyupload_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(modifyupload.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(modifyupload.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div);
			}

			destroy_component$1(modifyupload);
		}
	};
}

// (268:3) {#if show_share_button}
function create_if_block_2(ctx) {
	let div;
	let sharebutton;
	let current;

	sharebutton = new ShareButton({
			props: {
				i18n: /*i18n*/ ctx[11],
				value: /*resolved_value*/ ctx[13],
				formatter: format_gallery_for_sharing
			}
		});

	sharebutton.$on("share", /*share_handler*/ ctx[34]);
	sharebutton.$on("error", /*error_handler*/ ctx[35]);

	return {
		c() {
			div = element("div");
			create_component$1(sharebutton.$$.fragment);
			attr(div, "class", "icon-button svelte-hpz95u");
		},
		m(target, anchor) {
			insert$1(target, div, anchor);
			mount_component$1(sharebutton, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const sharebutton_changes = {};
			if (dirty[0] & /*i18n*/ 2048) sharebutton_changes.i18n = /*i18n*/ ctx[11];
			if (dirty[0] & /*resolved_value*/ 8192) sharebutton_changes.value = /*resolved_value*/ ctx[13];
			sharebutton.$set(sharebutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(sharebutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(sharebutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div);
			}

			destroy_component$1(sharebutton);
		}
	};
}

// (293:5) {#if entry.caption}
function create_if_block_1(ctx) {
	let div;
	let t_value = /*entry*/ ctx[43].caption + "";
	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "caption-label svelte-hpz95u");
		},
		m(target, anchor) {
			insert$1(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*resolved_value*/ 8192 && t_value !== (t_value = /*entry*/ ctx[43].caption + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach$1(div);
			}
		}
	};
}

// (279:3) {#each resolved_value as entry, i}
function create_each_block(ctx) {
	let button;
	let image_1;
	let t0;
	let t1;
	let button_aria_label_value;
	let current;
	let mounted;
	let dispose;

	image_1 = new Image$1({
			props: {
				alt: /*entry*/ ctx[43].caption || "",
				src: typeof /*entry*/ ctx[43].image === "string"
				? /*entry*/ ctx[43].image
				: /*entry*/ ctx[43].image.url,
				loading: "lazy"
			}
		});

	let if_block = /*entry*/ ctx[43].caption && create_if_block_1(ctx);

	function click_handler_3() {
		return /*click_handler_3*/ ctx[36](/*i*/ ctx[45]);
	}

	return {
		c() {
			button = element("button");
			create_component$1(image_1.$$.fragment);
			t0 = space$1();
			if (if_block) if_block.c();
			t1 = space$1();
			attr(button, "class", "thumbnail-item thumbnail-lg svelte-hpz95u");
			attr(button, "aria-label", button_aria_label_value = "Thumbnail " + (/*i*/ ctx[45] + 1) + " of " + /*resolved_value*/ ctx[13].length);
			toggle_class(button, "selected", /*selected_index*/ ctx[1] === /*i*/ ctx[45]);
		},
		m(target, anchor) {
			insert$1(target, button, anchor);
			mount_component$1(image_1, button, null);
			append(button, t0);
			if (if_block) if_block.m(button, null);
			append(button, t1);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", click_handler_3);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const image_1_changes = {};
			if (dirty[0] & /*resolved_value*/ 8192) image_1_changes.alt = /*entry*/ ctx[43].caption || "";

			if (dirty[0] & /*resolved_value*/ 8192) image_1_changes.src = typeof /*entry*/ ctx[43].image === "string"
			? /*entry*/ ctx[43].image
			: /*entry*/ ctx[43].image.url;

			image_1.$set(image_1_changes);

			if (/*entry*/ ctx[43].caption) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(button, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty[0] & /*resolved_value*/ 8192 && button_aria_label_value !== (button_aria_label_value = "Thumbnail " + (/*i*/ ctx[45] + 1) + " of " + /*resolved_value*/ ctx[13].length)) {
				attr(button, "aria-label", button_aria_label_value);
			}

			if (!current || dirty[0] & /*selected_index*/ 2) {
				toggle_class(button, "selected", /*selected_index*/ ctx[1] === /*i*/ ctx[45]);
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(image_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(image_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(button);
			}

			destroy_component$1(image_1);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (173:1) <Empty unpadded_box={true} size="large">
function create_default_slot$1(ctx) {
	let imageicon;
	let current;
	imageicon = new Image({});

	return {
		c() {
			create_component$1(imageicon.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(imageicon, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$1(imageicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(imageicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(imageicon, detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let t;
	let current_block_type_index;
	let if_block1;
	let if_block1_anchor;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[26]);
	let if_block0 = /*show_label*/ ctx[2] && create_if_block_7(ctx);
	const if_block_creators = [create_if_block$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[0] == null || /*resolved_value*/ ctx[13] == null || /*resolved_value*/ ctx[13].length === 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space$1();
			if_block1.c();
			if_block1_anchor = empty$1();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert$1(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert$1(target, if_block1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(window_1, "resize", /*onwindowresize*/ ctx[26]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*show_label*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*show_label*/ 4) {
						transition_in$1(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_7(ctx);
					if_block0.c();
					transition_in$1(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros$1();

				transition_out$1(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros$1();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros$1();

				transition_out$1(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros$1();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in$1(if_block1, 1);
				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block0);
			transition_in$1(if_block1);
			current = true;
		},
		o(local) {
			transition_out$1(if_block0);
			transition_out$1(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(t);
				detach$1(if_block1_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if_blocks[current_block_type_index].d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let previous;
	let next;
	let selected_image;
	let { show_label = true } = $$props;
	let { label } = $$props;
	let { value = null } = $$props;
	let { columns = [2] } = $$props;
	let { rows = undefined } = $$props;
	let { height = "auto" } = $$props;
	let { preview } = $$props;
	let { allow_preview = true } = $$props;
	let { object_fit = "cover" } = $$props;
	let { show_share_button = false } = $$props;
	let { show_download_button = false } = $$props;
	let { i18n } = $$props;
	let { selected_index = null } = $$props;
	let { interactive } = $$props;
	const dispatch = createEventDispatcher$1();

	// tracks whether the value of the gallery was reset
	let was_reset = true;

	let resolved_value = null;
	let prev_value = value;

	if (selected_index == null && preview && value?.length) {
		selected_index = 0;
	}

	let old_selected_index = selected_index;

	function handle_preview_click(event) {
		const element = event.target;
		const x = event.offsetX;
		const width = element.offsetWidth;
		const centerX = width / 2;

		if (x < centerX) {
			$$invalidate(1, selected_index = previous);
		} else {
			$$invalidate(1, selected_index = next);
		}
	}

	function on_keydown(e) {
		switch (e.code) {
			case "Escape":
				e.preventDefault();
				$$invalidate(1, selected_index = null);
				break;
			case "ArrowLeft":
				e.preventDefault();
				$$invalidate(1, selected_index = previous);
				break;
			case "ArrowRight":
				e.preventDefault();
				$$invalidate(1, selected_index = next);
				break;
		}
	}

	let el = [];
	let container_element;

	async function scroll_to_img(index) {
		if (typeof index !== "number") return;
		await tick();
		if (el[index] === undefined) return;
		el[index]?.focus();
		const { left: container_left, width: container_width } = container_element.getBoundingClientRect();
		const { left, width } = el[index].getBoundingClientRect();
		const relative_left = left - container_left;
		const pos = relative_left + width / 2 - container_width / 2 + container_element.scrollLeft;

		if (container_element && typeof container_element.scrollTo === "function") {
			container_element.scrollTo({
				left: pos < 0 ? 0 : pos,
				behavior: "smooth"
			});
		}
	}

	let client_height = 0;
	let window_height = 0;

	// Unlike `gr.Image()`, images specified via remote URLs are not cached in the server
	// and their remote URLs are directly passed to the client as `value[].image.url`.
	// The `download` attribute of the <a> tag doesn't work for remote URLs (https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#download),
	// so we need to download the image via JS as below.
	const fetch_implementation = getContext("fetch_implementation");

	async function download(file_url, name) {
		let response;

		try {
			response = await fetch_implementation(file_url);
		} catch(error) {
			if (error instanceof TypeError) {
				// If CORS is not allowed (https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#checking_that_the_fetch_was_successful),
				// open the link in a new tab instead, mimicing the behavior of the `download` attribute for remote URLs,
				// which is not ideal, but a reasonable fallback.
				window.open(file_url, "_blank", "noreferrer");

				return;
			}

			throw error;
		}

		const blob = await response.blob();
		const url = URL.createObjectURL(blob);
		const link = document.createElement("a");
		link.href = url;
		link.download = name;
		link.click();
		URL.revokeObjectURL(url);
	}

	function onwindowresize() {
		$$invalidate(17, window_height = window_1.innerHeight);
	}

	const click_handler = () => {
		const image = selected_image?.image;

		if (image == null) {
			return;
		}

		const { url, orig_name } = image;

		if (url) {
			download(url, orig_name ?? "image");
		}
	};

	const clear_handler = () => $$invalidate(1, selected_index = null);
	const click_handler_1 = event => handle_preview_click(event);

	function button_binding($$value, i) {
		binding_callbacks$1[$$value ? 'unshift' : 'push'](() => {
			el[i] = $$value;
			$$invalidate(14, el);
		});
	}

	const click_handler_2 = i => $$invalidate(1, selected_index = i);

	function div1_binding($$value) {
		binding_callbacks$1[$$value ? 'unshift' : 'push'](() => {
			container_element = $$value;
			$$invalidate(15, container_element);
		});
	}

	const clear_handler_1 = () => $$invalidate(0, value = null);

	function share_handler(event) {
		bubble.call(this, $$self, event);
	}

	function error_handler(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler_3 = i => $$invalidate(1, selected_index = i);

	function div1_elementresize_handler() {
		client_height = this.clientHeight;
		$$invalidate(16, client_height);
	}

	$$self.$$set = $$props => {
		if ('show_label' in $$props) $$invalidate(2, show_label = $$props.show_label);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('columns' in $$props) $$invalidate(4, columns = $$props.columns);
		if ('rows' in $$props) $$invalidate(5, rows = $$props.rows);
		if ('height' in $$props) $$invalidate(6, height = $$props.height);
		if ('preview' in $$props) $$invalidate(22, preview = $$props.preview);
		if ('allow_preview' in $$props) $$invalidate(7, allow_preview = $$props.allow_preview);
		if ('object_fit' in $$props) $$invalidate(8, object_fit = $$props.object_fit);
		if ('show_share_button' in $$props) $$invalidate(9, show_share_button = $$props.show_share_button);
		if ('show_download_button' in $$props) $$invalidate(10, show_download_button = $$props.show_download_button);
		if ('i18n' in $$props) $$invalidate(11, i18n = $$props.i18n);
		if ('selected_index' in $$props) $$invalidate(1, selected_index = $$props.selected_index);
		if ('interactive' in $$props) $$invalidate(12, interactive = $$props.interactive);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value, was_reset*/ 8388609) {
			$$invalidate(23, was_reset = value == null || value.length === 0 ? true : was_reset);
		}

		if ($$self.$$.dirty[0] & /*value*/ 1) {
			$$invalidate(13, resolved_value = value == null
			? null
			: value.map(data => ({ image: data.image, caption: data.caption })));
		}

		if ($$self.$$.dirty[0] & /*prev_value, value, was_reset, preview, selected_index*/ 29360131) {
			if (!dequal(prev_value, value)) {
				// When value is falsy (clear button or first load),
				// preview determines the selected image
				if (was_reset) {
					$$invalidate(1, selected_index = preview && value?.length ? 0 : null);
					$$invalidate(23, was_reset = false);
				} else // gallery has at least as many elements as it did before
				{
					$$invalidate(
						1,
						selected_index = selected_index != null && value != null && selected_index < value.length
						? selected_index
						: null
					);
				}

				dispatch("change");
				$$invalidate(24, prev_value = value);
			}
		}

		if ($$self.$$.dirty[0] & /*selected_index, resolved_value*/ 8194) {
			previous = ((selected_index ?? 0) + (resolved_value?.length ?? 0) - 1) % (resolved_value?.length ?? 0);
		}

		if ($$self.$$.dirty[0] & /*selected_index, resolved_value*/ 8194) {
			next = ((selected_index ?? 0) + 1) % (resolved_value?.length ?? 0);
		}

		if ($$self.$$.dirty[0] & /*selected_index, old_selected_index, resolved_value*/ 33562626) {
			{
				if (selected_index !== old_selected_index) {
					$$invalidate(25, old_selected_index = selected_index);

					if (selected_index !== null) {
						dispatch("select", {
							index: selected_index,
							value: resolved_value?.[selected_index]
						});
					}
				}
			}
		}

		if ($$self.$$.dirty[0] & /*allow_preview, selected_index*/ 130) {
			if (allow_preview) {
				scroll_to_img(selected_index);
			}
		}

		if ($$self.$$.dirty[0] & /*selected_index, resolved_value*/ 8194) {
			$$invalidate(18, selected_image = selected_index != null && resolved_value != null
			? resolved_value[selected_index]
			: null);
		}
	};

	return [
		value,
		selected_index,
		show_label,
		label,
		columns,
		rows,
		height,
		allow_preview,
		object_fit,
		show_share_button,
		show_download_button,
		i18n,
		interactive,
		resolved_value,
		el,
		container_element,
		client_height,
		window_height,
		selected_image,
		handle_preview_click,
		on_keydown,
		download,
		preview,
		was_reset,
		prev_value,
		old_selected_index,
		onwindowresize,
		click_handler,
		clear_handler,
		click_handler_1,
		button_binding,
		click_handler_2,
		div1_binding,
		clear_handler_1,
		share_handler,
		error_handler,
		click_handler_3,
		div1_elementresize_handler
	];
}

class Gallery extends SvelteComponent$1 {
	constructor(options) {
		super();

		init$1(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal$1,
			{
				show_label: 2,
				label: 3,
				value: 0,
				columns: 4,
				rows: 5,
				height: 6,
				preview: 22,
				allow_preview: 7,
				object_fit: 8,
				show_share_button: 9,
				show_download_button: 10,
				i18n: 11,
				selected_index: 1,
				interactive: 12
			},
			null,
			[-1, -1]
		);
	}
}

const Gallery$1 = Gallery;

/* home/runner/work/gradio/gradio/js/gallery/Index.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent,
	add_flush_callback,
	assign,
	bind,
	binding_callbacks,
	check_outros,
	create_component,
	destroy_component,
	detach,
	empty,
	get_spread_object,
	get_spread_update,
	group_outros,
	init,
	insert,
	mount_component,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} = window.__gradio__svelte__internal;const { createEventDispatcher } = window.__gradio__svelte__internal;
function create_else_block(ctx) {
	let gallery;
	let updating_selected_index;
	let updating_value;
	let current;

	function gallery_selected_index_binding(value) {
		/*gallery_selected_index_binding*/ ctx[24](value);
	}

	function gallery_value_binding(value) {
		/*gallery_value_binding*/ ctx[25](value);
	}

	let gallery_props = {
		label: /*label*/ ctx[4],
		show_label: /*show_label*/ ctx[3],
		columns: /*columns*/ ctx[12],
		rows: /*rows*/ ctx[13],
		height: /*height*/ ctx[14],
		preview: /*preview*/ ctx[15],
		object_fit: /*object_fit*/ ctx[17],
		interactive: /*interactive*/ ctx[19],
		allow_preview: /*allow_preview*/ ctx[16],
		show_share_button: /*show_share_button*/ ctx[18],
		show_download_button: /*show_download_button*/ ctx[20],
		i18n: /*gradio*/ ctx[21].i18n
	};

	if (/*selected_index*/ ctx[1] !== void 0) {
		gallery_props.selected_index = /*selected_index*/ ctx[1];
	}

	if (/*value*/ ctx[0] !== void 0) {
		gallery_props.value = /*value*/ ctx[0];
	}

	gallery = new Gallery$1({ props: gallery_props });
	binding_callbacks.push(() => bind(gallery, 'selected_index', gallery_selected_index_binding));
	binding_callbacks.push(() => bind(gallery, 'value', gallery_value_binding));
	gallery.$on("change", /*change_handler*/ ctx[26]);
	gallery.$on("select", /*select_handler*/ ctx[27]);
	gallery.$on("share", /*share_handler*/ ctx[28]);
	gallery.$on("error", /*error_handler*/ ctx[29]);

	return {
		c() {
			create_component(gallery.$$.fragment);
		},
		m(target, anchor) {
			mount_component(gallery, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const gallery_changes = {};
			if (dirty[0] & /*label*/ 16) gallery_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*show_label*/ 8) gallery_changes.show_label = /*show_label*/ ctx[3];
			if (dirty[0] & /*columns*/ 4096) gallery_changes.columns = /*columns*/ ctx[12];
			if (dirty[0] & /*rows*/ 8192) gallery_changes.rows = /*rows*/ ctx[13];
			if (dirty[0] & /*height*/ 16384) gallery_changes.height = /*height*/ ctx[14];
			if (dirty[0] & /*preview*/ 32768) gallery_changes.preview = /*preview*/ ctx[15];
			if (dirty[0] & /*object_fit*/ 131072) gallery_changes.object_fit = /*object_fit*/ ctx[17];
			if (dirty[0] & /*interactive*/ 524288) gallery_changes.interactive = /*interactive*/ ctx[19];
			if (dirty[0] & /*allow_preview*/ 65536) gallery_changes.allow_preview = /*allow_preview*/ ctx[16];
			if (dirty[0] & /*show_share_button*/ 262144) gallery_changes.show_share_button = /*show_share_button*/ ctx[18];
			if (dirty[0] & /*show_download_button*/ 1048576) gallery_changes.show_download_button = /*show_download_button*/ ctx[20];
			if (dirty[0] & /*gradio*/ 2097152) gallery_changes.i18n = /*gradio*/ ctx[21].i18n;

			if (!updating_selected_index && dirty[0] & /*selected_index*/ 2) {
				updating_selected_index = true;
				gallery_changes.selected_index = /*selected_index*/ ctx[1];
				add_flush_callback(() => updating_selected_index = false);
			}

			if (!updating_value && dirty[0] & /*value*/ 1) {
				updating_value = true;
				gallery_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			gallery.$set(gallery_changes);
		},
		i(local) {
			if (current) return;
			transition_in(gallery.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(gallery.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(gallery, detaching);
		}
	};
}

// (53:1) {#if interactive && no_value}
function create_if_block(ctx) {
	let basefileupload;
	let current;

	basefileupload = new BaseFileUpload({
			props: {
				value: null,
				root: /*root*/ ctx[5],
				label: /*label*/ ctx[4],
				file_count: "multiple",
				file_types: ["image"],
				i18n: /*gradio*/ ctx[21].i18n,
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	basefileupload.$on("upload", /*upload_handler*/ ctx[23]);

	return {
		c() {
			create_component(basefileupload.$$.fragment);
		},
		m(target, anchor) {
			mount_component(basefileupload, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const basefileupload_changes = {};
			if (dirty[0] & /*root*/ 32) basefileupload_changes.root = /*root*/ ctx[5];
			if (dirty[0] & /*label*/ 16) basefileupload_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*gradio*/ 2097152) basefileupload_changes.i18n = /*gradio*/ ctx[21].i18n;

			if (dirty[0] & /*gradio*/ 2097152 | dirty[1] & /*$$scope*/ 1) {
				basefileupload_changes.$$scope = { dirty, ctx };
			}

			basefileupload.$set(basefileupload_changes);
		},
		i(local) {
			if (current) return;
			transition_in(basefileupload.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(basefileupload.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(basefileupload, detaching);
		}
	};
}

// (54:2) <BaseFileUpload    value={null}    {root}    {label}    file_count={"multiple"}    file_types={["image"]}    i18n={gradio.i18n}    on:upload={(e) => {     const files = Array.isArray(e.detail) ? e.detail : [e.detail];     value = files.map((x) => ({ image: x, caption: null }));     gradio.dispatch("upload", value);    }}   >
function create_default_slot_1(ctx) {
	let uploadtext;
	let current;

	uploadtext = new UploadText({
			props: {
				i18n: /*gradio*/ ctx[21].i18n,
				type: "gallery"
			}
		});

	return {
		c() {
			create_component(uploadtext.$$.fragment);
		},
		m(target, anchor) {
			mount_component(uploadtext, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const uploadtext_changes = {};
			if (dirty[0] & /*gradio*/ 2097152) uploadtext_changes.i18n = /*gradio*/ ctx[21].i18n;
			uploadtext.$set(uploadtext_changes);
		},
		i(local) {
			if (current) return;
			transition_in(uploadtext.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(uploadtext.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(uploadtext, detaching);
		}
	};
}

// (36:0) <Block  {visible}  variant="solid"  padding={false}  {elem_id}  {elem_classes}  {container}  {scale}  {min_width}  allow_overflow={false}  height={typeof height === "number" ? height : undefined} >
function create_default_slot(ctx) {
	let statustracker;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const statustracker_spread_levels = [
		{
			autoscroll: /*gradio*/ ctx[21].autoscroll
		},
		{ i18n: /*gradio*/ ctx[21].i18n },
		/*loading_status*/ ctx[2]
	];

	let statustracker_props = {};

	for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
		statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
	}

	statustracker = new Static({ props: statustracker_props });
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*interactive*/ ctx[19] && /*no_value*/ ctx[22]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			create_component(statustracker.$$.fragment);
			t = space();
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(statustracker, target, anchor);
			insert(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const statustracker_changes = (dirty[0] & /*gradio, loading_status*/ 2097156)
			? get_spread_update(statustracker_spread_levels, [
					dirty[0] & /*gradio*/ 2097152 && {
						autoscroll: /*gradio*/ ctx[21].autoscroll
					},
					dirty[0] & /*gradio*/ 2097152 && { i18n: /*gradio*/ ctx[21].i18n },
					dirty[0] & /*loading_status*/ 4 && get_spread_object(/*loading_status*/ ctx[2])
				])
			: {};

			statustracker.$set(statustracker_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(statustracker.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(statustracker.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(if_block_anchor);
			}

			destroy_component(statustracker, detaching);
			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				visible: /*visible*/ ctx[8],
				variant: "solid",
				padding: false,
				elem_id: /*elem_id*/ ctx[6],
				elem_classes: /*elem_classes*/ ctx[7],
				container: /*container*/ ctx[9],
				scale: /*scale*/ ctx[10],
				min_width: /*min_width*/ ctx[11],
				allow_overflow: false,
				height: typeof /*height*/ ctx[14] === "number"
				? /*height*/ ctx[14]
				: undefined,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(block.$$.fragment);
		},
		m(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const block_changes = {};
			if (dirty[0] & /*visible*/ 256) block_changes.visible = /*visible*/ ctx[8];
			if (dirty[0] & /*elem_id*/ 64) block_changes.elem_id = /*elem_id*/ ctx[6];
			if (dirty[0] & /*elem_classes*/ 128) block_changes.elem_classes = /*elem_classes*/ ctx[7];
			if (dirty[0] & /*container*/ 512) block_changes.container = /*container*/ ctx[9];
			if (dirty[0] & /*scale*/ 1024) block_changes.scale = /*scale*/ ctx[10];
			if (dirty[0] & /*min_width*/ 2048) block_changes.min_width = /*min_width*/ ctx[11];

			if (dirty[0] & /*height*/ 16384) block_changes.height = typeof /*height*/ ctx[14] === "number"
			? /*height*/ ctx[14]
			: undefined;

			if (dirty[0] & /*root, label, gradio, value, interactive, no_value, show_label, columns, rows, height, preview, object_fit, allow_preview, show_share_button, show_download_button, selected_index, loading_status*/ 8384575 | dirty[1] & /*$$scope*/ 1) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(block, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let no_value;
	let { loading_status } = $$props;
	let { show_label } = $$props;
	let { label } = $$props;
	let { root } = $$props;
	let { elem_id = "" } = $$props;
	let { elem_classes = [] } = $$props;
	let { visible = true } = $$props;
	let { value = null } = $$props;
	let { container = true } = $$props;
	let { scale = null } = $$props;
	let { min_width = undefined } = $$props;
	let { columns = [2] } = $$props;
	let { rows = undefined } = $$props;
	let { height = "auto" } = $$props;
	let { preview } = $$props;
	let { allow_preview = true } = $$props;
	let { selected_index = null } = $$props;
	let { object_fit = "cover" } = $$props;
	let { show_share_button = false } = $$props;
	let { interactive } = $$props;
	let { show_download_button = false } = $$props;
	let { gradio } = $$props;
	const dispatch = createEventDispatcher();

	const upload_handler = e => {
		const files = Array.isArray(e.detail) ? e.detail : [e.detail];
		$$invalidate(0, value = files.map(x => ({ image: x, caption: null })));
		gradio.dispatch("upload", value);
	};

	function gallery_selected_index_binding(value) {
		selected_index = value;
		$$invalidate(1, selected_index);
	}

	function gallery_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	const change_handler = () => gradio.dispatch("change", value);
	const select_handler = e => gradio.dispatch("select", e.detail);
	const share_handler = e => gradio.dispatch("share", e.detail);
	const error_handler = e => gradio.dispatch("error", e.detail);

	$$self.$$set = $$props => {
		if ('loading_status' in $$props) $$invalidate(2, loading_status = $$props.loading_status);
		if ('show_label' in $$props) $$invalidate(3, show_label = $$props.show_label);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('root' in $$props) $$invalidate(5, root = $$props.root);
		if ('elem_id' in $$props) $$invalidate(6, elem_id = $$props.elem_id);
		if ('elem_classes' in $$props) $$invalidate(7, elem_classes = $$props.elem_classes);
		if ('visible' in $$props) $$invalidate(8, visible = $$props.visible);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('container' in $$props) $$invalidate(9, container = $$props.container);
		if ('scale' in $$props) $$invalidate(10, scale = $$props.scale);
		if ('min_width' in $$props) $$invalidate(11, min_width = $$props.min_width);
		if ('columns' in $$props) $$invalidate(12, columns = $$props.columns);
		if ('rows' in $$props) $$invalidate(13, rows = $$props.rows);
		if ('height' in $$props) $$invalidate(14, height = $$props.height);
		if ('preview' in $$props) $$invalidate(15, preview = $$props.preview);
		if ('allow_preview' in $$props) $$invalidate(16, allow_preview = $$props.allow_preview);
		if ('selected_index' in $$props) $$invalidate(1, selected_index = $$props.selected_index);
		if ('object_fit' in $$props) $$invalidate(17, object_fit = $$props.object_fit);
		if ('show_share_button' in $$props) $$invalidate(18, show_share_button = $$props.show_share_button);
		if ('interactive' in $$props) $$invalidate(19, interactive = $$props.interactive);
		if ('show_download_button' in $$props) $$invalidate(20, show_download_button = $$props.show_download_button);
		if ('gradio' in $$props) $$invalidate(21, gradio = $$props.gradio);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value*/ 1) {
			$$invalidate(22, no_value = Array.isArray(value) ? value.length === 0 : !value);
		}

		if ($$self.$$.dirty[0] & /*selected_index*/ 2) {
			(dispatch("prop_change", { selected_index }));
		}
	};

	return [
		value,
		selected_index,
		loading_status,
		show_label,
		label,
		root,
		elem_id,
		elem_classes,
		visible,
		container,
		scale,
		min_width,
		columns,
		rows,
		height,
		preview,
		allow_preview,
		object_fit,
		show_share_button,
		interactive,
		show_download_button,
		gradio,
		no_value,
		upload_handler,
		gallery_selected_index_binding,
		gallery_value_binding,
		change_handler,
		select_handler,
		share_handler,
		error_handler
	];
}

class Index extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				loading_status: 2,
				show_label: 3,
				label: 4,
				root: 5,
				elem_id: 6,
				elem_classes: 7,
				visible: 8,
				value: 0,
				container: 9,
				scale: 10,
				min_width: 11,
				columns: 12,
				rows: 13,
				height: 14,
				preview: 15,
				allow_preview: 16,
				selected_index: 1,
				object_fit: 17,
				show_share_button: 18,
				interactive: 19,
				show_download_button: 20,
				gradio: 21
			},
			null,
			[-1, -1]
		);
	}
}

export { Gallery$1 as BaseGallery, Index as default };
//# sourceMappingURL=Index-b43351a0.js.map
